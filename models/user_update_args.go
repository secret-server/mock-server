// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// UserUpdateArgs User update options
//
// swagger:model UserUpdateArgs
type UserUpdateArgs struct {

	// The id of the date format to use when displaying dates to this user. These options are defined in Admin > Configuration.
	DateOptionID int32 `json:"dateOptionId,omitempty"`

	// The user’s name as displayed in the user interface.
	DisplayName string `json:"displayName,omitempty"`

	// Whether Duo two-factor authentication is enabled.
	DuoTwoFactor bool `json:"duoTwoFactor,omitempty"`

	// The user's email address. Used by the system to send reports, access requests, and other notifications.
	EmailAddress string `json:"emailAddress,omitempty"`

	// Whether the user account is enabled. Disabled users are unable to log in and do not consume a user license.
	Enabled bool `json:"enabled,omitempty"`

	// Whether FIDO2 two-factor authentication is enabled.
	Fido2TwoFactor bool `json:"fido2TwoFactor,omitempty"`

	// A list of group ids for the groups that can manage this user. If not set, the user is managed by all users with the ‘Administer Users’ role permission.
	GroupOwners []int32 `json:"groupOwners"`

	// User ID. Must match ID in path.
	// Minimum: 1
	ID int32 `json:"id,omitempty"`

	// Whether this is an application account. Application accounts are used for automation, cannot log in using the UI, and do not consume a user license.
	IsApplicationAccount bool `json:"isApplicationAccount,omitempty"`

	// Whether the user is managed by the groups specified in GroupOwners or is managed by all users with the ‘Administer Users’ role permission.
	IsGroupOwnerUpdate bool `json:"isGroupOwnerUpdate,omitempty"`

	// Whether the user is locked out. A locked out user cannot log in.
	IsLockedOut bool `json:"isLockedOut,omitempty"`

	// Number of login failures to allow before the account is locked out. Set to 0 for unlimited login attempts.
	// Minimum: 0
	LoginFailures *int32 `json:"loginFailures,omitempty"`

	// Whether OATH two-factor authentication is enabled.
	OathTwoFactor bool `json:"oathTwoFactor,omitempty"`

	// The password used by local accounts to log in.
	Password string `json:"password,omitempty"`

	// Whether RADIUS two-factor authentication is enabled.
	RadiusTwoFactor bool `json:"radiusTwoFactor,omitempty"`

	// When a user account uses RADIUS two-factor authentication, this property is the user name of the RADIUS account used to authenticate this user.
	RadiusUserName string `json:"radiusUserName,omitempty"`

	// The id of the time format to use when displaying times to this user. These options are defined in Admin > Configuration.
	TimeOptionID int32 `json:"timeOptionId,omitempty"`

	// Whether two-factor authentication is enabled.
	TwoFactor bool `json:"twoFactor,omitempty"`
}

// Validate validates this user update args
func (m *UserUpdateArgs) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLoginFailures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UserUpdateArgs) validateID(formats strfmt.Registry) error {
	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if err := validate.MinimumInt("id", "body", int64(m.ID), 1, false); err != nil {
		return err
	}

	return nil
}

func (m *UserUpdateArgs) validateLoginFailures(formats strfmt.Registry) error {
	if swag.IsZero(m.LoginFailures) { // not required
		return nil
	}

	if err := validate.MinimumInt("loginFailures", "body", int64(*m.LoginFailures), 0, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this user update args based on context it is used
func (m *UserUpdateArgs) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *UserUpdateArgs) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *UserUpdateArgs) UnmarshalBinary(b []byte) error {
	var res UserUpdateArgs
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
