// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TokenResponse API access token response
//
// swagger:model TokenResponse
type TokenResponse struct {

	// Authentication token
	// Required: true
	AccessToken *string `json:"access_token"`

	// Authentication token expiration time, in seconds
	// Required: true
	ExpiresIn *string `json:"expires_in"`

	// Refresh token.  This is only provided when the server is set to allow refresh tokens for web services and when the session timeout duration is not set to Unlimited.
	RefreshToken string `json:"refresh_token,omitempty"`

	// Authentication token type
	// Required: true
	// Enum: [bearer]
	TokenType *string `json:"token_type"`
}

// Validate validates this token response
func (m *TokenResponse) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccessToken(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExpiresIn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTokenType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TokenResponse) validateAccessToken(formats strfmt.Registry) error {

	if err := validate.Required("access_token", "body", m.AccessToken); err != nil {
		return err
	}

	return nil
}

func (m *TokenResponse) validateExpiresIn(formats strfmt.Registry) error {

	if err := validate.Required("expires_in", "body", m.ExpiresIn); err != nil {
		return err
	}

	return nil
}

var tokenResponseTypeTokenTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["bearer"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		tokenResponseTypeTokenTypePropEnum = append(tokenResponseTypeTokenTypePropEnum, v)
	}
}

const (

	// TokenResponseTokenTypeBearer captures enum value "bearer"
	TokenResponseTokenTypeBearer string = "bearer"
)

// prop value enum
func (m *TokenResponse) validateTokenTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, tokenResponseTypeTokenTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TokenResponse) validateTokenType(formats strfmt.Registry) error {

	if err := validate.Required("token_type", "body", m.TokenType); err != nil {
		return err
	}

	// value enum
	if err := m.validateTokenTypeEnum("token_type", "body", *m.TokenType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this token response based on context it is used
func (m *TokenResponse) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TokenResponse) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TokenResponse) UnmarshalBinary(b []byte) error {
	var res TokenResponse
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
