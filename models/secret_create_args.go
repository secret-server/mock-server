// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SecretCreateArgs Secret create options
//
// swagger:model SecretCreateArgs
type SecretCreateArgs struct {

	// Whether the secret’s password is automatically rotated on a schedule.
	AutoChangeEnabled bool `json:"autoChangeEnabled,omitempty"`

	// Whether the Secret should be immediately queued for Remote Password Change upon successful import.
	ChangePasswordNow bool `json:"changePasswordNow,omitempty"`

	// Whether the secret’s password is automatically changed when a secret is checked in. This is a security feature that prevents a use of the password retrieved from check-out after the secret is checked in.
	CheckOutChangePasswordEnabled bool `json:"checkOutChangePasswordEnabled,omitempty"`

	// Whether the user must check-out the secret to view it. Checking out gives the user exclusive access to the secret for a specified period or until the secret is checked in.
	CheckOutEnabled bool `json:"checkOutEnabled,omitempty"`

	// The number of minutes that a secret will remain checked out.
	CheckOutIntervalMinutes *int32 `json:"checkOutIntervalMinutes,omitempty"`

	// Whether the search indexing should be delayed to the background process. This can speed up bulk secret creation scripts by offloading the task of indexing the new secrets to the background task at the trade-off of not having search indexes immediately available.
	DelayIndexing *bool `json:"delayIndexing,omitempty"`

	// Whether the secret inherits permissions from the containing folder.
	EnableInheritPermissions *bool `json:"enableInheritPermissions,omitempty"`

	// Whether the secret policy is inherited from the containing folder.
	EnableInheritSecretPolicy bool `json:"enableInheritSecretPolicy,omitempty"`

	// If the secret is contained in a folder, the id of the containing folder. Set to null or -1 for secrets that are in the root folder.
	FolderID *int32 `json:"folderId,omitempty"`

	// An array of values for the secret fields defined in the secret template.
	// Required: true
	Items []*RestSecretItem `json:"items"`

	// When an SSH secret is proxied, you can choose to connect as another user and then do an su to the current secret’s user. This is a common practice for connecting with a lower privileged account and then switching to the root user.
	LauncherConnectAsSecretID *int32 `json:"launcherConnectAsSecretId,omitempty"`

	// The name to display for the secret.
	// Required: true
	Name *string `json:"name"`

	// The id of the password change script to use on applicable web password secrets.
	PasswordTypeWebScriptID *int32 `json:"passwordTypeWebScriptId,omitempty"`

	// Whether sessions launched on this secret use Secret Server’s proxying or connect directly.
	ProxyEnabled bool `json:"proxyEnabled,omitempty"`

	// Whether the user must enter a comment to view the secret.
	RequiresComment bool `json:"requiresComment,omitempty"`

	// The id of the secret policy that controls the security and other settings of the secret. Set to null to not assign a secret policy.
	SecretPolicyID *int32 `json:"secretPolicyId,omitempty"`

	// The id of the secret template that defines the fields and properties of the secret.
	// Required: true
	// Minimum: 1
	SecretTemplateID *int32 `json:"secretTemplateId"`

	// Whether session recording is enabled.
	SessionRecordingEnabled bool `json:"sessionRecordingEnabled,omitempty"`

	// The id of the distributed engine site that is used by this secret for operations such as password changing.
	// Minimum: 1
	SiteID int32 `json:"siteId,omitempty"`

	// SSH key options.
	SSHKeyArgs *SSHKeyArgs `json:"sshKeyArgs,omitempty"`

	// Whether the web launcher will require the browser to run in incognito mode.
	WebLauncherRequiresIncognitoMode bool `json:"webLauncherRequiresIncognitoMode,omitempty"`
}

// Validate validates this secret create args
func (m *SecretCreateArgs) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateItems(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecretTemplateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSiteID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSSHKeyArgs(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecretCreateArgs) validateItems(formats strfmt.Registry) error {

	if err := validate.Required("items", "body", m.Items); err != nil {
		return err
	}

	for i := 0; i < len(m.Items); i++ {
		if swag.IsZero(m.Items[i]) { // not required
			continue
		}

		if m.Items[i] != nil {
			if err := m.Items[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("items" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SecretCreateArgs) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *SecretCreateArgs) validateSecretTemplateID(formats strfmt.Registry) error {

	if err := validate.Required("secretTemplateId", "body", m.SecretTemplateID); err != nil {
		return err
	}

	if err := validate.MinimumInt("secretTemplateId", "body", int64(*m.SecretTemplateID), 1, false); err != nil {
		return err
	}

	return nil
}

func (m *SecretCreateArgs) validateSiteID(formats strfmt.Registry) error {
	if swag.IsZero(m.SiteID) { // not required
		return nil
	}

	if err := validate.MinimumInt("siteId", "body", int64(m.SiteID), 1, false); err != nil {
		return err
	}

	return nil
}

func (m *SecretCreateArgs) validateSSHKeyArgs(formats strfmt.Registry) error {
	if swag.IsZero(m.SSHKeyArgs) { // not required
		return nil
	}

	if m.SSHKeyArgs != nil {
		if err := m.SSHKeyArgs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sshKeyArgs")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sshKeyArgs")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this secret create args based on the context it is used
func (m *SecretCreateArgs) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateItems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSSHKeyArgs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecretCreateArgs) contextValidateItems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Items); i++ {

		if m.Items[i] != nil {

			if swag.IsZero(m.Items[i]) { // not required
				return nil
			}

			if err := m.Items[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("items" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SecretCreateArgs) contextValidateSSHKeyArgs(ctx context.Context, formats strfmt.Registry) error {

	if m.SSHKeyArgs != nil {

		if swag.IsZero(m.SSHKeyArgs) { // not required
			return nil
		}

		if err := m.SSHKeyArgs.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sshKeyArgs")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sshKeyArgs")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SecretCreateArgs) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SecretCreateArgs) UnmarshalBinary(b []byte) error {
	var res SecretCreateArgs
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
