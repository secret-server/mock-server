// Code generated by go-swagger; DO NOT EDIT.

package users

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
    "errors"
    "net/url"
    golangswaggerpaths "path"

    "github.com/go-openapi/swag"
)

// UsersServiceLookupURL generates an URL for the users service lookup operation
type UsersServiceLookupURL struct {
    FilterDomainID                      *int32
    FilterExcludeInboxRuleIDSubscribers *int32
    FilterIncludeInactive               *bool
    FilterSearchFields                  []string
    FilterSearchText                    *string
    FilterUserIds                       []int64
    Skip                                *int32
    SortBy0Direction                    *string
    SortBy0Name                         *string
    SortBy0Priority                     *int32
    Take                                *int32

    _basePath string
    // avoid unkeyed usage
    _ struct{}
}

// WithBasePath sets the base path for this url builder, only required when it's different from the
// base path specified in the swagger spec.
// When the value of the base path is an empty string
func (o *UsersServiceLookupURL) WithBasePath(bp string) *UsersServiceLookupURL {
    o.SetBasePath(bp)
    return o
}

// SetBasePath sets the base path for this url builder, only required when it's different from the
// base path specified in the swagger spec.
// When the value of the base path is an empty string
func (o *UsersServiceLookupURL) SetBasePath(bp string) {
    o._basePath = bp
}

// Build a url path and query string
func (o *UsersServiceLookupURL) Build() (*url.URL, error) {
    var _result url.URL

    var _path = "/api/v1/users/lookup"

    _basePath := o._basePath
    if _basePath == "" {
        _basePath = "/SecretServer"
    }
    _result.Path = golangswaggerpaths.Join(_basePath, _path)

    qs := make(url.Values)

    var filterDomainIDQ string
    if o.FilterDomainID != nil {
        filterDomainIDQ = swag.FormatInt32(*o.FilterDomainID)
    }
    if filterDomainIDQ != "" {
        qs.Set("filter.domainId", filterDomainIDQ)
    }

    var filterExcludeInboxRuleIDSubscribersQ string
    if o.FilterExcludeInboxRuleIDSubscribers != nil {
        filterExcludeInboxRuleIDSubscribersQ = swag.FormatInt32(*o.FilterExcludeInboxRuleIDSubscribers)
    }
    if filterExcludeInboxRuleIDSubscribersQ != "" {
        qs.Set("filter.excludeInboxRuleIdSubscribers", filterExcludeInboxRuleIDSubscribersQ)
    }

    var filterIncludeInactiveQ string
    if o.FilterIncludeInactive != nil {
        filterIncludeInactiveQ = swag.FormatBool(*o.FilterIncludeInactive)
    }
    if filterIncludeInactiveQ != "" {
        qs.Set("filter.includeInactive", filterIncludeInactiveQ)
    }

    var filterSearchFieldsIR []string
    for _, filterSearchFieldsI := range o.FilterSearchFields {
        filterSearchFieldsIS := filterSearchFieldsI
        if filterSearchFieldsIS != "" {
            filterSearchFieldsIR = append(filterSearchFieldsIR, filterSearchFieldsIS)
        }
    }

    filterSearchFields := swag.JoinByFormat(filterSearchFieldsIR, "multi")

    for _, qsv := range filterSearchFields {
        qs.Add("filter.searchFields", qsv)
    }

    var filterSearchTextQ string
    if o.FilterSearchText != nil {
        filterSearchTextQ = *o.FilterSearchText
    }
    if filterSearchTextQ != "" {
        qs.Set("filter.searchText", filterSearchTextQ)
    }

    var filterUserIdsIR []string
    for _, filterUserIdsI := range o.FilterUserIds {
        filterUserIdsIS := swag.FormatInt64(filterUserIdsI)
        if filterUserIdsIS != "" {
            filterUserIdsIR = append(filterUserIdsIR, filterUserIdsIS)
        }
    }

    filterUserIds := swag.JoinByFormat(filterUserIdsIR, "multi")

    for _, qsv := range filterUserIds {
        qs.Add("filter.userIds", qsv)
    }

    var skipQ string
    if o.Skip != nil {
        skipQ = swag.FormatInt32(*o.Skip)
    }
    if skipQ != "" {
        qs.Set("skip", skipQ)
    }

    var sortBy0DirectionQ string
    if o.SortBy0Direction != nil {
        sortBy0DirectionQ = *o.SortBy0Direction
    }
    if sortBy0DirectionQ != "" {
        qs.Set("sortBy[0].direction", sortBy0DirectionQ)
    }

    var sortBy0NameQ string
    if o.SortBy0Name != nil {
        sortBy0NameQ = *o.SortBy0Name
    }
    if sortBy0NameQ != "" {
        qs.Set("sortBy[0].name", sortBy0NameQ)
    }

    var sortBy0PriorityQ string
    if o.SortBy0Priority != nil {
        sortBy0PriorityQ = swag.FormatInt32(*o.SortBy0Priority)
    }
    if sortBy0PriorityQ != "" {
        qs.Set("sortBy[0].priority", sortBy0PriorityQ)
    }

    var takeQ string
    if o.Take != nil {
        takeQ = swag.FormatInt32(*o.Take)
    }
    if takeQ != "" {
        qs.Set("take", takeQ)
    }

    _result.RawQuery = qs.Encode()

    return &_result, nil
}

// Must is a helper function to panic when the url builder returns an error
func (o *UsersServiceLookupURL) Must(u *url.URL, err error) *url.URL {
    if err != nil {
        panic(err)
    }
    if u == nil {
        panic("url can't be nil")
    }
    return u
}

// String returns the string representation of the path with query string
func (o *UsersServiceLookupURL) String() string {
    return o.Must(o.Build()).String()
}

// BuildFull builds a full url with scheme, host, path and query string
func (o *UsersServiceLookupURL) BuildFull(scheme, host string) (*url.URL, error) {
    if scheme == "" {
        return nil, errors.New("scheme is required for a full url on UsersServiceLookupURL")
    }
    if host == "" {
        return nil, errors.New("host is required for a full url on UsersServiceLookupURL")
    }

    base, err := o.Build()
    if err != nil {
        return nil, err
    }

    base.Scheme = scheme
    base.Host = host
    return base, nil
}

// StringFull returns the string representation of a complete url
func (o *UsersServiceLookupURL) StringFull(scheme, host string) string {
    return o.Must(o.BuildFull(scheme, host)).String()
}
