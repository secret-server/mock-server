// Code generated by go-swagger; DO NOT EDIT.

package restapi

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
)

var (
	// SwaggerJSON embedded version of the swagger document used at generation time
	SwaggerJSON json.RawMessage
	// FlatSwaggerJSON embedded flattened version of the swagger document used at generation time
	FlatSwaggerJSON json.RawMessage
)

func init() {
	SwaggerJSON = json.RawMessage([]byte(`{
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "schemes": [
    "http",
    "https"
  ],
  "swagger": "2.0",
  "info": {
    "description": "REST API documentation for Secret Server. This document describes how to use the REST API. All requests require an authentication token; please see the \u003ca href=\"../OAuth/\"\u003eauthentication document\u003c/a\u003e for more information. The \u003ca href=\"swagger.json\"\u003eSwagger specification\u003c/a\u003e for this API is also available.",
    "title": "Secret Server Rest API",
    "termsOfService": "https://delinea.com/eula",
    "contact": {
      "name": "Support",
      "url": "https://delinea.com"
    },
    "version": "11.7.2"
  },
  "basePath": "/SecretServer",
  "paths": {
    "/api/v1/roles": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Search, filter, sort, and page Roles",
        "tags": [
          "Roles"
        ],
        "summary": "Search Roles",
        "operationId": "RolesService_GetAll",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "Only return roles assigned to this group id.  Will be ignored if UserId is set",
            "name": "filter.groupId",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to include inactive Roles in the results",
            "name": "filter.includeInactive",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "Only return roles assigned to this user id.  Will supercede GroupId if set",
            "name": "filter.userId",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Number of records to skip before taking results",
            "name": "skip",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort direction",
            "name": "sortBy[0].direction",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort field name",
            "name": "sortBy[0].name",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Priority index. Sorts with lower values are executed earlier",
            "name": "sortBy[0].priority",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Maximum number of records to include in results",
            "name": "take",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Role search result object",
            "schema": {
              "$ref": "#/definitions/PagingOfRoleModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      },
      "post": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Create a new Role",
        "tags": [
          "Roles"
        ],
        "summary": "Create Role",
        "operationId": "RolesService_Create",
        "parameters": [
          {
            "description": "args",
            "name": "args",
            "in": "body",
            "schema": {
              "description": "args",
              "$ref": "#/definitions/RoleCreateArgs"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Role object",
            "schema": {
              "$ref": "#/definitions/RoleModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/roles/stub": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Return the default values for a new Role",
        "tags": [
          "Roles"
        ],
        "summary": "Get Role Stub",
        "operationId": "RolesService_Stub",
        "responses": {
          "200": {
            "description": "Role object",
            "schema": {
              "$ref": "#/definitions/RoleModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/roles/{id}": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Get Role by Role ID",
        "tags": [
          "Roles"
        ],
        "summary": "Get Role",
        "operationId": "RolesService_Get",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Role model result object",
            "schema": {
              "$ref": "#/definitions/RoleModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      },
      "patch": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Update a single Role by ID",
        "tags": [
          "Roles"
        ],
        "summary": "Update Role",
        "operationId": "RolesService_Update",
        "parameters": [
          {
            "description": "Role update options",
            "name": "args",
            "in": "body",
            "schema": {
              "description": "Role update options",
              "$ref": "#/definitions/RolePatchArgs"
            }
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Role ID",
            "name": "id",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Role object",
            "schema": {
              "$ref": "#/definitions/RoleModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/roles/{id}/groups": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Get assigned Groups by RoleId",
        "tags": [
          "Roles"
        ],
        "summary": "Get Role Groups",
        "operationId": "RolesService_GetRoleGroups",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "boolean",
            "description": "Whether to include inactive users in the results",
            "name": "filter.includeInactiveUsersForGroup",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "Filter only users in a specific domain",
            "name": "filter.userDomainId",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Number of records to skip before taking results",
            "name": "skip",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort direction",
            "name": "sortBy[0].direction",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort field name",
            "name": "sortBy[0].name",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Priority index. Sorts with lower values are executed earlier",
            "name": "sortBy[0].priority",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Maximum number of records to include in results",
            "name": "take",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Role Group summary result object",
            "schema": {
              "$ref": "#/definitions/PagingOfRoleGroupSummaryAndGroupMembershipFilter"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/roles/{id}/permissions": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Get Permissions assigned to a single Role by Role ID",
        "tags": [
          "Roles"
        ],
        "summary": "Get Assigned Role Permissions",
        "operationId": "RolesService_GetRolePermissions",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Number of records to skip before taking results",
            "name": "skip",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort direction",
            "name": "sortBy[0].direction",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort field name",
            "name": "sortBy[0].name",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Priority index. Sorts with lower values are executed earlier",
            "name": "sortBy[0].priority",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Maximum number of records to include in results",
            "name": "take",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Role Permission model result object",
            "schema": {
              "$ref": "#/definitions/PagingOfRolePermissionModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      },
      "put": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Update all Permissions assigned to Role",
        "tags": [
          "Roles"
        ],
        "summary": "Update Role Permission Assignments",
        "operationId": "RolesService_UpdatePermissions",
        "parameters": [
          {
            "description": "args",
            "name": "args",
            "in": "body",
            "schema": {
              "description": "args",
              "$ref": "#/definitions/RolePermissionsAssignmentRequest"
            }
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success / Fail",
            "schema": {
              "$ref": "#/definitions/RolePermissionsAssignmentResponse"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/roles/{id}/permissions/unassigned": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Get unassigned Role Permissions matching the type of a specific Role by Role ID",
        "tags": [
          "Roles"
        ],
        "summary": "Get Unassigned Role Permissions",
        "operationId": "RolesService_GetAllRolePermissionsByType",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Number of records to skip before taking results",
            "name": "skip",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort direction",
            "name": "sortBy[0].direction",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort field name",
            "name": "sortBy[0].name",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Priority index. Sorts with lower values are executed earlier",
            "name": "sortBy[0].priority",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Maximum number of records to include in results",
            "name": "take",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Role model result object",
            "schema": {
              "$ref": "#/definitions/PagingOfRolePermissionModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/roles/{roleId}/groups": {
      "patch": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Update Groups assigned to a Role by sending list(s) of Group IDs to add/remove",
        "tags": [
          "Roles"
        ],
        "summary": "Patch Role Group Assignments",
        "operationId": "RolesService_PatchGroups",
        "parameters": [
          {
            "description": "Role Groups update options",
            "name": "args",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/RoleGroupsPatchArgs"
            }
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Role ID",
            "name": "roleId",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Role object",
            "schema": {
              "$ref": "#/definitions/RoleGroupsPatchResult"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Search, filter, sort, and page secrets (removed from 11.3.3, but exposed for completeness)",
        "tags": [
          "Secrets"
        ],
        "summary": "Search Secrets",
        "operationId": "SecretsService_Search",
        "parameters": [
          {
            "type": "boolean",
            "description": "Whether to allow DoubleLocks as part of the search. True by default.",
            "name": "filter.allowDoubleLocks",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to return the total number of secrets matching the filters. False by default. If false, the total can be retrieved separately by calling   /api/v1/secrets/search-total with the same arguments used in the search.",
            "name": "filter.doNotCalculateTotal",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Only include Secrets with this DoubleLock ID assigned in the search results.",
            "name": "filter.doubleLockId",
            "in": "query"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi",
            "description": "An array of names of Secret Template fields to return.  Only exposed fields can be returned.",
            "name": "filter.extendedFields",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "If not null, return only secrets matching the specified extended mapping type as defined on the secret’s template.",
            "name": "filter.extendedTypeId",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "If not null, returns only secrets within the specified folder.",
            "name": "filter.folderId",
            "in": "query"
          },
          {
            "type": "string",
            "description": "If not null, returns only secrets with a certain heartbeat status.",
            "name": "filter.heartbeatStatus",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to include active secrets in results (when excluded equals true).",
            "name": "filter.includeActive",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to include inactive secrets in results.",
            "name": "filter.includeInactive",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to include restricted secrets in results. Restricted secrets are secrets that are DoubleLocked, require approval, or require a comment to view.",
            "name": "filter.includeRestricted",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to include secrets in subfolders of the specified folder.",
            "name": "filter.includeSubFolders",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to do an exact match of the search text or a partial match. If an exact match, the entire secret name, field value, or list option in a list field must match the search text.",
            "name": "filter.isExactMatch",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to only include secrets whose template has Remote Password Changing enabled.",
            "name": "filter.onlyRPCEnabled",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "When true only Secrets where you are not the owner and the Secret was shared explicitly with your user id will be returned.",
            "name": "filter.onlySharedWithMe",
            "in": "query"
          },
          {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "collectionFormat": "multi",
            "description": "If not null, returns only secrets matching the specified password types.",
            "name": "filter.passwordTypeIds",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Specify whether to filter by List, View, Edit, or Owner permission. Default is List.",
            "name": "filter.permissionRequired",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Specify whether to search All, Recent, or Favorites",
            "name": "filter.scope",
            "in": "query"
          },
          {
            "type": "string",
            "description": "If set, restricts the search to only match secrets where the value of the field specified by name contains the search text.",
            "name": "filter.searchField",
            "in": "query"
          },
          {
            "type": "string",
            "description": "If set, restricts the search to only match secrets where the value of the field specified by the slug name contains the search text. This will override SearchField.",
            "name": "filter.searchFieldSlug",
            "in": "query"
          },
          {
            "type": "string",
            "description": "The text to match in the secret name, field value, or list field contents.",
            "name": "filter.searchText",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "If not null, returns only secrets matching the specified template.",
            "name": "filter.secretTemplateId",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "If not null, returns only secrets within a the specified site.",
            "name": "filter.siteId",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Number of records to skip before taking results",
            "name": "skip",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort direction",
            "name": "sortBy[0].direction",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort field name",
            "name": "sortBy[0].name",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Priority index. Sorts with lower values are executed earlier",
            "name": "sortBy[0].priority",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Maximum number of records to include in results",
            "name": "take",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret search result object",
            "schema": {
              "$ref": "#/definitions/PagingOfSecretSummary"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      },
      "post": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Create a new secret",
        "tags": [
          "Secrets"
        ],
        "summary": "Create Secret",
        "operationId": "SecretsService_CreateSecret",
        "parameters": [
          {
            "description": "Secret creation options",
            "name": "secretCreateArgs",
            "in": "body",
            "schema": {
              "description": "Secret creation options",
              "$ref": "#/definitions/SecretCreateArgs"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Secret object",
            "schema": {
              "$ref": "#/definitions/SecretModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/extended-search-details": {
      "post": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Pass an array of secret IDs, presumably the results of a secret search and get extended details such as has launchers or is favorite.",
        "tags": [
          "Secrets"
        ],
        "summary": "Secret Search Extended Details",
        "operationId": "SecretsService_GetSecretExtendedSearchDetails",
        "parameters": [
          {
            "description": "args",
            "name": "args",
            "in": "body",
            "schema": {
              "description": "args",
              "$ref": "#/definitions/SecretSearchExtendedArgs"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Secret search extended details",
            "schema": {
              "description": "Secret search extended details",
              "type": "array",
              "items": {
                "$ref": "#/definitions/SecretSearchExtendedSummary"
              }
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/lookup": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Search, filter, sort, and page secrets, returning only secret ID and name",
        "tags": [
          "Secrets"
        ],
        "summary": "Lookup Secrets with Search",
        "operationId": "SecretsService_SearchSecretLookup",
        "parameters": [
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to allow DoubleLocks as part of the search. True by default.",
            "name": "filter.allowDoubleLocks",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to return the total number of secrets matching the filters. False by default. If false, the total can be retrieved separately by calling /v1/secrets/search-total with the same arguments used in the search.",
            "name": "filter.doNotCalculateTotal",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "Only include Secrets with this DoubleLock ID assigned in the search results.",
            "name": "filter.doubleLockId",
            "in": "query"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi",
            "description": "An array of names of Secret Template fields to return.  Only exposed fields can be returned.",
            "name": "filter.extendedFields",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "If not null, return only secrets matching the specified extended mapping type as defined on the secret’s template.",
            "name": "filter.extendedTypeId",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "If not null, returns only secrets within the specified folder.",
            "name": "filter.folderId",
            "in": "query"
          },
          {
            "type": "string",
            "x-nullable": true,
            "description": "If not null, returns only secrets with a certain heartbeat status.",
            "name": "filter.heartbeatStatus",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to include active secrets in results (when excluded equals true).",
            "name": "filter.includeActive",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to include inactive secrets in results.",
            "name": "filter.includeInactive",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to include restricted secrets in results. Restricted secrets are secrets that are DoubleLocked, require approval, or require a comment to view.",
            "name": "filter.includeRestricted",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to include secrets in subfolders of the specified folder.",
            "name": "filter.includeSubFolders",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to do an exact match of the search text or a partial match. If an exact match, the entire secret name, field value, or list option in a list field must match the search text.",
            "name": "filter.isExactMatch",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to only include secrets whose template has Remote Password Changing enabled.",
            "name": "filter.onlyRPCEnabled",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to only return secrets that are or are not checked out by the querying user. If null, returns secrets regardless of whether they are checked out.",
            "name": "filter.onlySecretsCheckedOutByUser",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "When true only Secrets where you are not the owner and the Secret was shared explicitly with your user id will be returned.",
            "name": "filter.onlySharedWithMe",
            "in": "query"
          },
          {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "collectionFormat": "multi",
            "description": "If not null, returns only secrets matching the specified password types.",
            "name": "filter.passwordTypeIds",
            "in": "query"
          },
          {
            "type": "string",
            "x-nullable": true,
            "description": "Specify whether to filter by List, View, Edit, or Owner permission. Default is List.",
            "name": "filter.permissionRequired",
            "in": "query"
          },
          {
            "type": "string",
            "x-nullable": true,
            "description": "Specify whether to search All, Recent, or Favorites",
            "name": "filter.scope",
            "in": "query"
          },
          {
            "type": "string",
            "description": "If set, restricts the search to only match secrets where the value of the field specified by name contains the search text.",
            "name": "filter.searchField",
            "in": "query"
          },
          {
            "type": "string",
            "description": "If set, restricts the search to only match secrets where the value of the field specified by the slug name contains the search text. This will override SearchField.",
            "name": "filter.searchFieldSlug",
            "in": "query"
          },
          {
            "type": "string",
            "description": "The text to match in the secret name, field value, or list field contents.",
            "name": "filter.searchText",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "If not null, returns only secrets matching the specified template.",
            "name": "filter.secretTemplateId",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "If not null, returns only secrets within a the specified site.",
            "name": "filter.siteId",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Number of records to skip before taking results",
            "name": "skip",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort direction",
            "name": "sortBy[0].direction",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort field name",
            "name": "sortBy[0].name",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Priority index. Sorts with lower values are executed earlier",
            "name": "sortBy[0].priority",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Maximum number of records to include in results",
            "name": "take",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret search result object",
            "schema": {
              "$ref": "#/definitions/PagingOfSecretLookup"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/lookup/{id}": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Look up secret by ID and return secret name and ID",
        "tags": [
          "Secrets"
        ],
        "summary": "Lookup Secret",
        "operationId": "SecretsService_GetLookup",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret lookup result object",
            "schema": {
              "$ref": "#/definitions/SecretLookup"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/secret-detail/{id}/general": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Retrieve details about a secret.",
        "tags": [
          "Secrets"
        ],
        "summary": "Get Secret Detail General",
        "operationId": "SecretsService_GetGeneral",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret Detail State View Model",
            "schema": {
              "description": "Secret Detail State View Model",
              "$ref": "#/definitions/SecretDetailGeneralModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/{id}": {
      "put": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Update a single secret by ID",
        "tags": [
          "Secrets"
        ],
        "summary": "Update Secret",
        "operationId": "SecretsService_UpdateSecret",
        "parameters": [
          {
            "description": "Secret update options",
            "name": "args",
            "in": "body",
            "schema": {
              "description": "Secret update options",
              "$ref": "#/definitions/SecretUpdateArgs"
            }
          },
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret object",
            "schema": {
              "$ref": "#/definitions/SecretModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      },
      "delete": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "A deactivated secret is hidden from users who do not have a role containing the View Inactive Secrets permission. Secret Server uses these \"soft deletes\" to maintain the audit history for all data. However, deactivated secrets are still accessible by administrators (like a permanent Recycle Bin) to ensure that audit history is maintained and to support recovery. A user must have the \"View Inactive Secrets\" permission in addition to Owner permission on a secret to access the secret View page for a deleted secret. To permanently remove all information on a secret, use the \"Erase Secret\" function.",
        "tags": [
          "Secrets"
        ],
        "summary": "Deactivate a Secret",
        "operationId": "SecretsService_Delete",
        "parameters": [
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Object deletion result",
            "schema": {
              "$ref": "#/definitions/DeletedModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/{id}/activate": {
      "put": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Undelete a Secret",
        "tags": [
          "Secrets"
        ],
        "summary": "Undelete a Secret",
        "operationId": "SecretsService_UndeleteSecret",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret",
            "schema": {
              "$ref": "#/definitions/SecretDetailGeneralModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/{id}/expiration": {
      "put": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Update a Secret expiration",
        "tags": [
          "Secrets"
        ],
        "summary": "Update a Secret expiration",
        "operationId": "SecretsService_UpdateExpiration",
        "parameters": [
          {
            "description": "args",
            "name": "args",
            "in": "body",
            "schema": {
              "description": "args",
              "$ref": "#/definitions/SecretDetailUpdateExpirationArgs"
            }
          },
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Updated secret settings",
            "schema": {
              "description": "Updated secret settings",
              "$ref": "#/definitions/SecretDetailSettingsModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/{id}/expire": {
      "post": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Expire a secret",
        "tags": [
          "Secrets"
        ],
        "summary": "Expire Secret",
        "operationId": "SecretsService_Expire",
        "parameters": [
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "description": "Secret options",
            "name": "restrictedArgs",
            "in": "body",
            "schema": {
              "description": "Secret options",
              "$ref": "#/definitions/SecretRestrictedArgs"
            }
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret summary object",
            "schema": {
              "$ref": "#/definitions/SecretSummary"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/{id}/fields/{slug}": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Get a secret data field",
        "produces": [
          "application/json",
          "application/octet-stream"
        ],
        "tags": [
          "Secrets"
        ],
        "summary": "Get Secret Field",
        "operationId": "SecretsService_GetField",
        "parameters": [
          {
            "type": "boolean",
            "description": "Whether to include inactive secrets in the results",
            "name": "includeInactive",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Don't check out the secret if needed",
            "name": "noAutoCheckout",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Secret field name",
            "name": "slug",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Secret field value. If the field is a file attachment, the content type will be ` + "`" + `application/octet-stream` + "`" + ` and the response body will be the file contents.",
            "schema": {
              "description": "String",
              "type": "string"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      },
      "put": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Update a secret data field",
        "consumes": [
          "application/json",
          "multipart/form-data"
        ],
        "tags": [
          "Secrets"
        ],
        "summary": "Update Secret Field",
        "operationId": "SecretsService_PutField",
        "parameters": [
          {
            "description": "Secret options",
            "name": "args",
            "in": "body",
            "schema": {
              "description": "Secret options",
              "$ref": "#/definitions/SecretItemUpdateArgs"
            }
          },
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Secret field name",
            "name": "slug",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "The updated value, or 'true' if the field is a file attachment",
            "schema": {
              "description": "String",
              "type": "string"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/{id}/fields/{slug}/list": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Get the items associated to a secret list data field",
        "tags": [
          "Secrets"
        ],
        "summary": "Get Secret List Field",
        "operationId": "SecretsService_GetListField",
        "parameters": [
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "Secret field name",
            "name": "slug",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Combined contents of all lists assigned to the secret field.",
            "schema": {
              "$ref": "#/definitions/CategorizedListItemValueResult"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/{id}/fields/{slug}/listdetails": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Get the lists associated to a secret list data field",
        "tags": [
          "Secrets"
        ],
        "summary": "Get Secret List Field List Data",
        "operationId": "SecretsService_GetListFieldListDefinitions",
        "parameters": [
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Number of records to skip before taking results",
            "name": "skip",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort direction",
            "name": "sortBy[0].direction",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort field name",
            "name": "sortBy[0].name",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Priority index. Sorts with lower values are executed earlier",
            "name": "sortBy[0].priority",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Maximum number of records to include in results",
            "name": "take",
            "in": "query"
          },
          {
            "type": "string",
            "description": "The field slug name of the list field. This is the fieldSlugName property of the SecretField object. By default, it is the lower-case field name with all spaces replaced with dashes (-).",
            "name": "slug",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Combined summary of all lists assigned to the secret field.",
            "schema": {
              "$ref": "#/definitions/PagingOfCategorizedListSummary"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      },
      "put": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Updates the lists associated to a secret list data field",
        "tags": [
          "Secrets"
        ],
        "summary": "Update Secret List Field List Data",
        "operationId": "SecretsService_UpdateListFieldListDefinitions",
        "parameters": [
          {
            "description": "Secret options",
            "name": "args",
            "in": "body",
            "schema": {
              "description": "Secret options",
              "$ref": "#/definitions/SecretListFieldListArgs"
            }
          },
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "Secret field name",
            "name": "slug",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Combined summary of all lists assigned to the secret field.",
            "schema": {
              "$ref": "#/definitions/PagingOfCategorizedListSummary"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      },
      "delete": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Deletes the lists associated to a secret list data field",
        "tags": [
          "Secrets"
        ],
        "summary": "Delete Secret List Field List Data",
        "operationId": "SecretsService_DeleteListFieldListDefinitions",
        "parameters": [
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "format": "uuid",
            "description": "Secret options",
            "name": "listGuid",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Secret field name",
            "name": "slug",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Combined summary of all lists assigned to the secret field.",
            "schema": {
              "$ref": "#/definitions/PagingOfCategorizedListSummary"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/{id}/heartbeat": {
      "post": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Check if secret is still valid",
        "tags": [
          "Secrets"
        ],
        "summary": "Run Secret Heartbeat",
        "operationId": "SecretsService_RunHeartBeat",
        "parameters": [
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret summary object",
            "schema": {
              "$ref": "#/definitions/SecretSummary"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/{id}/restricted": {
      "post": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Get a restricted secret",
        "tags": [
          "Secrets"
        ],
        "summary": "Get Restricted Secret",
        "operationId": "SecretsService_GetRestricted",
        "parameters": [
          {
            "description": "Secret options",
            "name": "args",
            "in": "body",
            "schema": {
              "description": "Secret options",
              "$ref": "#/definitions/SecretRestrictedArgs"
            }
          },
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret object",
            "schema": {
              "$ref": "#/definitions/SecretModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/{id}/state": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Retrieve state about a Secret such as whether it requires approval, doublelock, checkout, or other restricted actions to be performed before calling the get the secret.",
        "tags": [
          "Secrets"
        ],
        "summary": "Get Secret State",
        "operationId": "SecretsService_GetSecretState",
        "parameters": [
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret Detail State View Model",
            "schema": {
              "$ref": "#/definitions/SecretDetailStateViewModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/users/lookup": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Search, filter, sort, and page users, returning only user ID and name",
        "tags": [
          "Users"
        ],
        "summary": "Lookup Users",
        "operationId": "UsersService_Lookup",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "If not null, filters users by Active Directory domain.",
            "name": "filter.domainId",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "When set all subscribers not subscribed directly to this inbox notification rule will be excluded.",
            "name": "filter.excludeInboxRuleIdSubscribers",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to include inactive users in the results.",
            "name": "filter.includeInactive",
            "in": "query"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi",
            "description": "User fields to search.",
            "name": "filter.searchFields",
            "in": "query"
          },
          {
            "type": "string",
            "description": "The text to match in the username, display name, or email address.",
            "name": "filter.searchText",
            "in": "query"
          },
          {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "collectionFormat": "multi",
            "description": "User Ids to search.",
            "name": "filter.userIds",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Number of records to skip before taking results",
            "name": "skip",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort direction",
            "name": "sortBy[0].direction",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort field name",
            "name": "sortBy[0].name",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Priority index. Sorts with lower values are executed earlier",
            "name": "sortBy[0].priority",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Maximum number of records to include in results",
            "name": "take",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "User search result object",
            "schema": {
              "$ref": "#/definitions/PagingOfUserLookup"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/users/{id}": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Get a single user by ID",
        "tags": [
          "Users"
        ],
        "summary": "Get User",
        "operationId": "UsersService_Get",
        "parameters": [
          {
            "type": "boolean",
            "description": "Whether to include inactive users in the results",
            "name": "includeInactive",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "User ID",
            "name": "id",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "User object",
            "schema": {
              "$ref": "#/definitions/UserModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      },
      "put": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Update a single user by ID",
        "tags": [
          "Users"
        ],
        "summary": "Update User",
        "operationId": "UsersService_UpdateUser",
        "parameters": [
          {
            "description": "User update options",
            "name": "args",
            "in": "body",
            "schema": {
              "description": "User update options",
              "$ref": "#/definitions/UserUpdateArgs"
            }
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "User ID",
            "name": "id",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "User object",
            "schema": {
              "$ref": "#/definitions/UserModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      },
      "patch": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Update included properties for user by Id",
        "tags": [
          "Users"
        ],
        "summary": "Update included properties for user by Id",
        "operationId": "UsersService_PatchUser",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "description": "patchModel",
            "name": "patchModel",
            "in": "body",
            "schema": {
              "description": "patchModel",
              "$ref": "#/definitions/PatchUserModel"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "User Configuration",
            "schema": {
              "$ref": "#/definitions/UserModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/users/{id}/roles": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Gets roles for user",
        "tags": [
          "Users"
        ],
        "summary": "Gets roles for user",
        "operationId": "UsersService_GetRoles",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "description": "Number of records to skip before taking results",
            "name": "skip",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort direction",
            "name": "sortBy[0].direction",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort field name",
            "name": "sortBy[0].name",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Priority index. Sorts with lower values are executed earlier",
            "name": "sortBy[0].priority",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Maximum number of records to include in results",
            "name": "take",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success / Fail",
            "schema": {
              "$ref": "#/definitions/PagingOfRoleSummary"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      },
      "put": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Update all roles on user",
        "tags": [
          "Users"
        ],
        "summary": "Update all roles on user",
        "operationId": "UsersService_UpdateUserRoles",
        "parameters": [
          {
            "description": "args",
            "name": "args",
            "in": "body",
            "schema": {
              "description": "args",
              "$ref": "#/definitions/RoleAssignments"
            }
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success / Fail",
            "schema": {
              "$ref": "#/definitions/RoleChangeStatusModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      },
      "post": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Add roles to existing user",
        "tags": [
          "Users"
        ],
        "summary": "Add roles to existing user",
        "operationId": "UsersService_CreateUserRoles",
        "parameters": [
          {
            "description": "args",
            "name": "args",
            "in": "body",
            "schema": {
              "description": "args",
              "$ref": "#/definitions/RoleAssignments"
            }
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success / Fail",
            "schema": {
              "$ref": "#/definitions/RoleChangeStatusModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/users/{userId}/roles-assigned": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Get the roles for a user by ID",
        "tags": [
          "Users"
        ],
        "summary": "Get User Roles",
        "operationId": "UsersService_GetUserRoles",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "description": "Number of records to skip before taking results",
            "name": "skip",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort direction",
            "name": "sortBy[0].direction",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort field name",
            "name": "sortBy[0].name",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Priority index. Sorts with lower values are executed earlier",
            "name": "sortBy[0].priority",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Maximum number of records to include in results",
            "name": "take",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "User ID",
            "name": "userId",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "User role summary",
            "schema": {
              "$ref": "#/definitions/PagingOfUserRoleSummary"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v2/secrets": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Search, filter, sort, and page secrets",
        "tags": [
          "Secrets"
        ],
        "summary": "Search Secrets",
        "operationId": "SecretsService_SearchV2",
        "parameters": [
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to allow DoubleLocks as part of the search. True by default.",
            "name": "filter.allowDoubleLocks",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to return the total number of secrets matching the filters. False by default. If false, the total can be retrieved separately by calling /v1/secrets/search-total with the same arguments used in the search.",
            "name": "filter.doNotCalculateTotal",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "Only include Secrets with this DoubleLock ID assigned in the search results.",
            "name": "filter.doubleLockId",
            "in": "query"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi",
            "description": "An array of names of Secret Template fields to return.  Only exposed fields can be returned.  This parameter will be ignored if ExtFieldsCombined is sent.",
            "name": "filter.extendedFields",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "If not null, return only secrets matching the specified extended mapping type as defined on the secret’s template.",
            "name": "filter.extendedTypeId",
            "in": "query"
          },
          {
            "type": "string",
            "description": "A comma delimited list of all extended fields to return.  All fields must be marked as exposed for display.  When populated this value will be used instead of ExtendedFields[].  Combining the fields decreases the size of the GET URL to avoid the 2048 character length restriction in IIS.",
            "name": "filter.extFieldsCombined",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "If not null, returns only secrets within the specified folder.",
            "name": "filter.folderId",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to only return secrets with or without launchers. If null, returns secrets regardless of whether they have launchers.",
            "name": "filter.hasLauncher",
            "in": "query"
          },
          {
            "type": "string",
            "x-nullable": true,
            "description": "If not null, returns only secrets with a certain heartbeat status.",
            "name": "filter.heartbeatStatus",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to include active secrets in results (when excluded equals true).",
            "name": "filter.includeActive",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to include inactive secrets in results.",
            "name": "filter.includeInactive",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to include restricted secrets in results. Restricted secrets are secrets that are DoubleLocked, require approval, or require a comment to view.",
            "name": "filter.includeRestricted",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to include secrets in subfolders of the specified folder.",
            "name": "filter.includeSubFolders",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to do an exact match of the search text or a partial match. If an exact match, the entire secret name, field value, or list option in a list field must match the search text.",
            "name": "filter.isExactMatch",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to only return secrets that are or are not checked out. If null, returns secrets regardless of whether they are checked out.",
            "name": "filter.onlyCheckedOutSecrets",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to only include secrets whose template has Remote Password Changing enabled.",
            "name": "filter.onlyRPCEnabled",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to only return secrets that are or are not checked out by the querying user. If null, returns secrets regardless of whether they are checked out.",
            "name": "filter.onlySecretsCheckedOutByUser",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "When true only Secrets where you are not the owner and the Secret was shared explicitly with your user id will be returned.",
            "name": "filter.onlySharedWithMe",
            "in": "query"
          },
          {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "collectionFormat": "multi",
            "description": "If not null, returns only secrets matching the specified password types.",
            "name": "filter.passwordTypeIds",
            "in": "query"
          },
          {
            "type": "string",
            "x-nullable": true,
            "description": "Specify whether to filter by List, View, Edit, or Owner permission. Default is List.",
            "name": "filter.permissionRequired",
            "in": "query"
          },
          {
            "type": "string",
            "x-nullable": true,
            "description": "Specify whether to search All, Recent, or Favorites",
            "name": "filter.scope",
            "in": "query"
          },
          {
            "type": "string",
            "description": "If set, restricts the search to only match secrets where the value of the field specified by name contains the search text.",
            "name": "filter.searchField",
            "in": "query"
          },
          {
            "type": "string",
            "description": "If set, restricts the search to only match secrets where the value of the field specified by the slug name contains the search text. This will override SearchField.",
            "name": "filter.searchFieldSlug",
            "in": "query"
          },
          {
            "type": "string",
            "description": "The text to match in the secret name, field value, or list field contents.",
            "name": "filter.searchText",
            "in": "query"
          },
          {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "collectionFormat": "multi",
            "description": "If not null or empty, returns only secrets matching the specified secret ids.",
            "name": "filter.secretIds",
            "in": "query"
          },
          {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "collectionFormat": "multi",
            "description": "If not null or empty, returns only secrets matching the specified templates.",
            "name": "filter.secretTemplateIds",
            "in": "query"
          },
          {
            "type": "string",
            "description": "A comma delimited list of all secret template IDs.  When populated this value will be used instead of SecretTemplateIds[].  Combining the fields decreases the size of the GET URL to avoid the 2048 character length restriction in IIS.",
            "name": "filter.secretTemplateIdsCombined",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "If not null, returns only secrets within a the specified site.",
            "name": "filter.siteId",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Number of records to skip before taking results",
            "name": "skip",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort direction",
            "name": "sortBy[0].direction",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort field name",
            "name": "sortBy[0].name",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Priority index. Sorts with lower values are executed earlier",
            "name": "sortBy[0].priority",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Maximum number of records to include in results",
            "name": "take",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret search result object",
            "schema": {
              "$ref": "#/definitions/PagingOfSecretSummary"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v2/secrets/{id}": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Get a single secret by ID",
        "tags": [
          "Secrets"
        ],
        "summary": "Get Secret",
        "operationId": "SecretsService_GetSecretV2",
        "parameters": [
          {
            "type": "boolean",
            "description": "Whether to include inactive secrets in the results",
            "name": "includeInactive",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Don't check out the secret if needed",
            "name": "noAutoCheckout",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret object",
            "schema": {
              "$ref": "#/definitions/SecretModelV2"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v2/secrets/{id}/activate": {
      "put": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Undelete a Secret",
        "tags": [
          "Secrets"
        ],
        "summary": "Undelete a Secret",
        "operationId": "SecretsService_UndeleteSecretV2",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret",
            "schema": {
              "$ref": "#/definitions/SecretDetailGeneralModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/oauth2/token": {
      "post": {
        "description": "Retrieve an access token for use with other API requests or refresh an access token.",
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "tags": [
          "Authentication"
        ],
        "summary": "Retrieve or Refresh Access Token",
        "operationId": "OAuth2Service_Authorize",
        "parameters": [
          {
            "enum": [
              "password",
              "refresh_token"
            ],
            "type": "string",
            "description": "Authentication grant type.  Use 'password' when authenticating, and 'refresh_token' when refreshing a token.",
            "name": "grant_type",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "Secret Server authentication username.  Required when authenticating.",
            "name": "username",
            "in": "formData"
          },
          {
            "type": "string",
            "description": "Secret Server authentication password.  Required when authenticating.",
            "name": "password",
            "in": "formData"
          },
          {
            "type": "string",
            "description": "The refresh token.  Required when refreshing a token.",
            "name": "refresh_token",
            "in": "formData"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful retrieval of an access token",
            "schema": {
              "$ref": "#/definitions/TokenResponse"
            }
          },
          "400": {
            "description": "An error occurred",
            "schema": {
              "$ref": "#/definitions/TokenErrorResponse"
            }
          }
        }
      }
    }
  },
  "definitions": {
    "AuthenticationFailedResponse": {
      "description": "Response object for authentication failures",
      "type": "object",
      "required": [
        "message"
      ],
      "properties": {
        "message": {
          "description": "Error message",
          "type": "string"
        }
      }
    },
    "BadRequestResponse": {
      "description": "Response object for invalid requests",
      "type": "object",
      "required": [
        "message"
      ],
      "properties": {
        "errorCode": {
          "description": "Error message code",
          "type": "string"
        },
        "message": {
          "description": "Error message",
          "type": "string"
        },
        "messageDetail": {
          "description": "Error message detail",
          "type": "string"
        },
        "modelState": {
          "description": "An object describing validation errors",
          "type": "object"
        }
      }
    },
    "CategorizedListItemValueResult": {
      "description": "CategorizedListItemValueResult",
      "type": "object",
      "properties": {
        "value": {
          "description": "Value",
          "type": "array",
          "items": {
            "$ref": "#/definitions/ICategorizedListItemValue"
          }
        }
      }
    },
    "CategorizedListSummary": {
      "description": "Query results",
      "type": "object",
      "properties": {
        "active": {
          "description": "Whether or not the list is active",
          "type": "boolean"
        },
        "categorizedListId": {
          "description": "List Id",
          "type": "string"
        },
        "description": {
          "description": "Description of the list",
          "type": "string"
        },
        "name": {
          "description": "Name of the list",
          "type": "string"
        },
        "numOptions": {
          "description": "The number of options in the list",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "DeletedModel": {
      "description": "Information about an object that was deleted",
      "type": "object",
      "properties": {
        "id": {
          "description": "ID of the deleted object",
          "type": "integer",
          "format": "int32"
        },
        "objectType": {
          "description": "Type of the deleted object",
          "type": "string"
        },
        "responseCodes": {
          "description": "List of response codes from the delete operation",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "GroupAssignedRoleModel": {
      "description": "All of the groups to which the user belongs that have this role",
      "type": "object",
      "properties": {
        "groupId": {
          "description": "GroupId",
          "type": "integer",
          "format": "int32"
        },
        "groupName": {
          "description": "GroupName",
          "type": "string"
        }
      }
    },
    "GroupMembershipFilter": {
      "description": "Group membership filter",
      "type": "object",
      "properties": {
        "includeInactiveUsersForGroup": {
          "description": "Whether to include inactive users in the results",
          "type": "boolean"
        },
        "userDomainId": {
          "description": "Filter only users in a specific domain",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        }
      }
    },
    "HeartbeatStatus": {
      "description": "Current status of heartbeat",
      "type": "string",
      "enum": [
        "Failed",
        "Success",
        "Pending",
        "Disabled",
        "UnableToConnect",
        "UnknownError",
        "IncompatibleHost",
        "AccountLockedOut",
        "DnsMismatch",
        "UnableToValidateServerPublicKey",
        "Processing",
        "ArgumentError",
        "AccessDenied"
      ]
    },
    "ICategorizedListItemValue": {
      "description": "The restricted hosts.",
      "type": "object",
      "properties": {
        "category": {
          "description": "Category",
          "type": "string"
        },
        "value": {
          "description": "Value",
          "type": "string"
        }
      }
    },
    "ISecretSummaryExtendedField": {
      "description": "Any requested extended fields from a lookup request",
      "type": "object",
      "properties": {
        "name": {
          "description": "Name",
          "type": "string"
        },
        "value": {
          "description": "Value",
          "type": "string"
        }
      }
    },
    "InternalServerErrorResponse": {
      "description": "Response object for internal server errors",
      "type": "object",
      "required": [
        "message",
        "exceptionMessage",
        "exceptionType",
        "stackTrace"
      ],
      "properties": {
        "exceptionMessage": {
          "description": "Error message from exception",
          "type": "string"
        },
        "exceptionType": {
          "description": "Exception type",
          "type": "string"
        },
        "message": {
          "description": "Error message",
          "type": "string"
        },
        "stackTrace": {
          "description": "Exception stack trace",
          "type": "string"
        }
      }
    },
    "PagingOfCategorizedListSummary": {
      "description": "Specify paging and sorting options for querying records and returning results",
      "type": "object",
      "properties": {
        "batchCount": {
          "description": "Number of result batches available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "currentPage": {
          "description": "Index of current result page",
          "type": "integer",
          "format": "int32"
        },
        "hasNext": {
          "description": "Whether there are any results in additional pages",
          "type": "boolean"
        },
        "hasPrev": {
          "description": "Whether there are any results in previous pages",
          "type": "boolean"
        },
        "nextSkip": {
          "description": "Correct value of 'skip' for the next page of results",
          "type": "integer",
          "format": "int32"
        },
        "pageCount": {
          "description": "Number of result pages available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "prevSkip": {
          "description": "Correct value of 'skip' for the previous page of results",
          "type": "integer",
          "format": "int32"
        },
        "records": {
          "description": "Query results",
          "type": "array",
          "items": {
            "$ref": "#/definitions/CategorizedListSummary"
          }
        },
        "severity": {
          "description": "Severity of any errors",
          "$ref": "#/definitions/Severity"
        },
        "skip": {
          "description": "Number of records to skip before taking results",
          "type": "integer",
          "format": "int32"
        },
        "sortBy": {
          "description": "List of sort properties",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Sort"
          }
        },
        "success": {
          "description": "Whether the query executed successfully",
          "type": "boolean"
        },
        "take": {
          "description": "Maximum number of records to include in results",
          "type": "integer",
          "format": "int32"
        },
        "total": {
          "description": "Total number of results available",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "PagingOfRoleGroupSummaryAndGroupMembershipFilter": {
      "description": "Specify filtering, paging, sorting options for querying records and returning results",
      "type": "object",
      "properties": {
        "batchCount": {
          "description": "Number of result batches available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "currentPage": {
          "description": "Index of current result page",
          "type": "integer",
          "format": "int32"
        },
        "filter": {
          "description": "Additional query options",
          "$ref": "#/definitions/GroupMembershipFilter"
        },
        "hasNext": {
          "description": "Whether there are any results in additional pages",
          "type": "boolean"
        },
        "hasPrev": {
          "description": "Whether there are any results in previous pages",
          "type": "boolean"
        },
        "nextSkip": {
          "description": "Correct value of 'skip' for the next page of results",
          "type": "integer",
          "format": "int32"
        },
        "pageCount": {
          "description": "Number of result pages available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "prevSkip": {
          "description": "Correct value of 'skip' for the previous page of results",
          "type": "integer",
          "format": "int32"
        },
        "records": {
          "description": "Query results",
          "type": "array",
          "items": {
            "$ref": "#/definitions/RoleGroupSummary"
          }
        },
        "severity": {
          "description": "Severity of any errors",
          "$ref": "#/definitions/Severity"
        },
        "skip": {
          "description": "Number of records to skip before taking results",
          "type": "integer",
          "format": "int32"
        },
        "sortBy": {
          "description": "List of sort properties",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Sort"
          }
        },
        "success": {
          "description": "Whether the query executed successfully",
          "type": "boolean"
        },
        "take": {
          "description": "Maximum number of records to include in results",
          "type": "integer",
          "format": "int32"
        },
        "total": {
          "description": "Total number of results available",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "PagingOfRoleModel": {
      "description": "Specify paging and sorting options for querying records and returning results",
      "type": "object",
      "properties": {
        "batchCount": {
          "description": "Number of result batches available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "currentPage": {
          "description": "Index of current result page",
          "type": "integer",
          "format": "int32"
        },
        "hasNext": {
          "description": "Whether there are any results in additional pages",
          "type": "boolean"
        },
        "hasPrev": {
          "description": "Whether there are any results in previous pages",
          "type": "boolean"
        },
        "nextSkip": {
          "description": "Correct value of 'skip' for the next page of results",
          "type": "integer",
          "format": "int32"
        },
        "pageCount": {
          "description": "Number of result pages available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "prevSkip": {
          "description": "Correct value of 'skip' for the previous page of results",
          "type": "integer",
          "format": "int32"
        },
        "records": {
          "description": "Query results",
          "type": "array",
          "items": {
            "$ref": "#/definitions/RoleModel"
          }
        },
        "severity": {
          "description": "Severity of any errors",
          "$ref": "#/definitions/Severity"
        },
        "skip": {
          "description": "Number of records to skip before taking results",
          "type": "integer",
          "format": "int32"
        },
        "sortBy": {
          "description": "List of sort properties",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Sort"
          }
        },
        "success": {
          "description": "Whether the query executed successfully",
          "type": "boolean"
        },
        "take": {
          "description": "Maximum number of records to include in results",
          "type": "integer",
          "format": "int32"
        },
        "total": {
          "description": "Total number of results available",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "PagingOfRolePermissionModel": {
      "description": "Specify paging and sorting options for querying records and returning results",
      "type": "object",
      "properties": {
        "batchCount": {
          "description": "Number of result batches available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "currentPage": {
          "description": "Index of current result page",
          "type": "integer",
          "format": "int32"
        },
        "hasNext": {
          "description": "Whether there are any results in additional pages",
          "type": "boolean"
        },
        "hasPrev": {
          "description": "Whether there are any results in previous pages",
          "type": "boolean"
        },
        "nextSkip": {
          "description": "Correct value of 'skip' for the next page of results",
          "type": "integer",
          "format": "int32"
        },
        "pageCount": {
          "description": "Number of result pages available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "prevSkip": {
          "description": "Correct value of 'skip' for the previous page of results",
          "type": "integer",
          "format": "int32"
        },
        "records": {
          "description": "Query results",
          "type": "array",
          "items": {
            "$ref": "#/definitions/RolePermissionModel"
          }
        },
        "severity": {
          "description": "Severity of any errors",
          "$ref": "#/definitions/Severity"
        },
        "skip": {
          "description": "Number of records to skip before taking results",
          "type": "integer",
          "format": "int32"
        },
        "sortBy": {
          "description": "List of sort properties",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Sort"
          }
        },
        "success": {
          "description": "Whether the query executed successfully",
          "type": "boolean"
        },
        "take": {
          "description": "Maximum number of records to include in results",
          "type": "integer",
          "format": "int32"
        },
        "total": {
          "description": "Total number of results available",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "PagingOfRoleSummary": {
      "description": "Specify paging and sorting options for querying records and returning results",
      "type": "object",
      "properties": {
        "batchCount": {
          "description": "Number of result batches available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "currentPage": {
          "description": "Index of current result page",
          "type": "integer",
          "format": "int32"
        },
        "hasNext": {
          "description": "Whether there are any results in additional pages",
          "type": "boolean"
        },
        "hasPrev": {
          "description": "Whether there are any results in previous pages",
          "type": "boolean"
        },
        "nextSkip": {
          "description": "Correct value of 'skip' for the next page of results",
          "type": "integer",
          "format": "int32"
        },
        "pageCount": {
          "description": "Number of result pages available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "prevSkip": {
          "description": "Correct value of 'skip' for the previous page of results",
          "type": "integer",
          "format": "int32"
        },
        "records": {
          "description": "Query results",
          "type": "array",
          "items": {
            "$ref": "#/definitions/RoleSummary"
          }
        },
        "severity": {
          "description": "Severity of any errors",
          "$ref": "#/definitions/Severity"
        },
        "skip": {
          "description": "Number of records to skip before taking results",
          "type": "integer",
          "format": "int32"
        },
        "sortBy": {
          "description": "List of sort properties",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Sort"
          }
        },
        "success": {
          "description": "Whether the query executed successfully",
          "type": "boolean"
        },
        "take": {
          "description": "Maximum number of records to include in results",
          "type": "integer",
          "format": "int32"
        },
        "total": {
          "description": "Total number of results available",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "PagingOfSecretLookup": {
      "description": "Specify paging and sorting options for querying records and returning results",
      "type": "object",
      "properties": {
        "batchCount": {
          "description": "Number of result batches available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "currentPage": {
          "description": "Index of current result page",
          "type": "integer",
          "format": "int32"
        },
        "hasNext": {
          "description": "Whether there are any results in additional pages",
          "type": "boolean"
        },
        "hasPrev": {
          "description": "Whether there are any results in previous pages",
          "type": "boolean"
        },
        "nextSkip": {
          "description": "Correct value of 'skip' for the next page of results",
          "type": "integer",
          "format": "int32"
        },
        "pageCount": {
          "description": "Number of result pages available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "prevSkip": {
          "description": "Correct value of 'skip' for the previous page of results",
          "type": "integer",
          "format": "int32"
        },
        "records": {
          "description": "Query results",
          "type": "array",
          "items": {
            "$ref": "#/definitions/SecretLookup"
          }
        },
        "severity": {
          "description": "Severity of any errors",
          "$ref": "#/definitions/Severity"
        },
        "skip": {
          "description": "Number of records to skip before taking results",
          "type": "integer",
          "format": "int32"
        },
        "sortBy": {
          "description": "List of sort properties",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Sort"
          }
        },
        "success": {
          "description": "Whether the query executed successfully",
          "type": "boolean"
        },
        "take": {
          "description": "Maximum number of records to include in results",
          "type": "integer",
          "format": "int32"
        },
        "total": {
          "description": "Total number of results available",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "PagingOfSecretSummary": {
      "description": "Specify paging and sorting options for querying records and returning results",
      "type": "object",
      "properties": {
        "batchCount": {
          "description": "Number of result batches available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "currentPage": {
          "description": "Index of current result page",
          "type": "integer",
          "format": "int32"
        },
        "hasNext": {
          "description": "Whether there are any results in additional pages",
          "type": "boolean"
        },
        "hasPrev": {
          "description": "Whether there are any results in previous pages",
          "type": "boolean"
        },
        "nextSkip": {
          "description": "Correct value of 'skip' for the next page of results",
          "type": "integer",
          "format": "int32"
        },
        "pageCount": {
          "description": "Number of result pages available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "prevSkip": {
          "description": "Correct value of 'skip' for the previous page of results",
          "type": "integer",
          "format": "int32"
        },
        "records": {
          "description": "Query results",
          "type": "array",
          "items": {
            "$ref": "#/definitions/SecretSummary"
          }
        },
        "severity": {
          "description": "Severity of any errors",
          "$ref": "#/definitions/Severity"
        },
        "skip": {
          "description": "Number of records to skip before taking results",
          "type": "integer",
          "format": "int32"
        },
        "sortBy": {
          "description": "List of sort properties",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Sort"
          }
        },
        "success": {
          "description": "Whether the query executed successfully",
          "type": "boolean"
        },
        "take": {
          "description": "Maximum number of records to include in results",
          "type": "integer",
          "format": "int32"
        },
        "total": {
          "description": "Total number of results available",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "PagingOfUserLookup": {
      "description": "Specify paging and sorting options for querying records and returning results",
      "type": "object",
      "properties": {
        "batchCount": {
          "description": "Number of result batches available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "currentPage": {
          "description": "Index of current result page",
          "type": "integer",
          "format": "int32"
        },
        "hasNext": {
          "description": "Whether there are any results in additional pages",
          "type": "boolean"
        },
        "hasPrev": {
          "description": "Whether there are any results in previous pages",
          "type": "boolean"
        },
        "nextSkip": {
          "description": "Correct value of 'skip' for the next page of results",
          "type": "integer",
          "format": "int32"
        },
        "pageCount": {
          "description": "Number of result pages available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "prevSkip": {
          "description": "Correct value of 'skip' for the previous page of results",
          "type": "integer",
          "format": "int32"
        },
        "records": {
          "description": "Query results",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UserLookup"
          }
        },
        "severity": {
          "description": "Severity of any errors",
          "$ref": "#/definitions/Severity"
        },
        "skip": {
          "description": "Number of records to skip before taking results",
          "type": "integer",
          "format": "int32"
        },
        "sortBy": {
          "description": "List of sort properties",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Sort"
          }
        },
        "success": {
          "description": "Whether the query executed successfully",
          "type": "boolean"
        },
        "take": {
          "description": "Maximum number of records to include in results",
          "type": "integer",
          "format": "int32"
        },
        "total": {
          "description": "Total number of results available",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "PagingOfUserRoleSummary": {
      "description": "Specify paging and sorting options for querying records and returning results",
      "type": "object",
      "properties": {
        "batchCount": {
          "description": "Number of result batches available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "currentPage": {
          "description": "Index of current result page",
          "type": "integer",
          "format": "int32"
        },
        "hasNext": {
          "description": "Whether there are any results in additional pages",
          "type": "boolean"
        },
        "hasPrev": {
          "description": "Whether there are any results in previous pages",
          "type": "boolean"
        },
        "nextSkip": {
          "description": "Correct value of 'skip' for the next page of results",
          "type": "integer",
          "format": "int32"
        },
        "pageCount": {
          "description": "Number of result pages available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "prevSkip": {
          "description": "Correct value of 'skip' for the previous page of results",
          "type": "integer",
          "format": "int32"
        },
        "records": {
          "description": "Query results",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UserRoleSummary"
          }
        },
        "severity": {
          "description": "Severity of any errors",
          "$ref": "#/definitions/Severity"
        },
        "skip": {
          "description": "Number of records to skip before taking results",
          "type": "integer",
          "format": "int32"
        },
        "sortBy": {
          "description": "List of sort properties",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Sort"
          }
        },
        "success": {
          "description": "Whether the query executed successfully",
          "type": "boolean"
        },
        "take": {
          "description": "Maximum number of records to include in results",
          "type": "integer",
          "format": "int32"
        },
        "total": {
          "description": "Total number of results available",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "PatchUserModel": {
      "description": "PatchUserModel",
      "type": "object",
      "properties": {
        "dateOptionId": {
          "description": "DateOptionId",
          "$ref": "#/definitions/UpdateFieldValueOfInt32"
        },
        "displayName": {
          "description": "Display name",
          "$ref": "#/definitions/UpdateFieldValueOfString"
        },
        "duoTwoFactor": {
          "description": "Whether Duo two-factor authentication is enabled",
          "$ref": "#/definitions/UpdateFieldValueOfBoolean"
        },
        "emailAddress": {
          "description": "Email address",
          "$ref": "#/definitions/UpdateFieldValueOfString"
        },
        "enabled": {
          "description": "Whether the user account is enabled",
          "$ref": "#/definitions/UpdateFieldValueOfBoolean"
        },
        "fido2TwoFactor": {
          "description": "Whether FIDO2 two-factor authentication is enabled",
          "$ref": "#/definitions/UpdateFieldValueOfBoolean"
        },
        "groupOwners": {
          "description": "GroupOwners",
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        },
        "id": {
          "description": "User ID. Must match ID in path",
          "type": "integer",
          "format": "int32"
        },
        "ipAddressRestrictionIds": {
          "description": "List of IP Address Restriction Ids for the user. This will completely replace whatever restrictions existed previously.",
          "$ref": "#/definitions/UpdateFieldValueOfInt32"
        },
        "isApplicationAccount": {
          "description": "IsApplicationAccount",
          "$ref": "#/definitions/UpdateFieldValueOfBoolean"
        },
        "isGroupOwnerUpdate": {
          "description": "IsGroupOwnerUpdate",
          "type": "boolean"
        },
        "isLockedOut": {
          "description": "Whether the user is locked out",
          "$ref": "#/definitions/UpdateFieldValueOfBoolean"
        },
        "loginFailures": {
          "description": "Number of login failures",
          "$ref": "#/definitions/UpdateFieldValueOfInt32"
        },
        "oathTwoFactor": {
          "description": "Whether OATH two-factor authentication is enabled",
          "$ref": "#/definitions/UpdateFieldValueOfBoolean"
        },
        "password": {
          "description": "Password",
          "$ref": "#/definitions/UpdateFieldValueOfString"
        },
        "radiusTwoFactor": {
          "description": "Whether RADIUS two-factor authentication is enabled",
          "$ref": "#/definitions/UpdateFieldValueOfBoolean"
        },
        "radiusUserName": {
          "description": "RADIUS username",
          "$ref": "#/definitions/UpdateFieldValueOfString"
        },
        "slackId": {
          "description": "Slack ID",
          "$ref": "#/definitions/UpdateFieldValueOfString"
        },
        "timeOptionId": {
          "description": "TimeOptionId",
          "$ref": "#/definitions/UpdateFieldValueOfInt32"
        },
        "twoFactor": {
          "description": "Whether two-factor authentication is enabled",
          "$ref": "#/definitions/UpdateFieldValueOfBoolean"
        }
      }
    },
    "RestSecretItem": {
      "description": "Secret data field item",
      "type": "object",
      "properties": {
        "fieldDescription": {
          "description": "Longer description of the secret field.",
          "type": "string"
        },
        "fieldId": {
          "description": "The id of the field definition from the secret template.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "fieldName": {
          "description": "The display name of the secret field.",
          "type": "string"
        },
        "fileAttachmentId": {
          "description": "If the field is a file attachment field, the id of the file attachment.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "filename": {
          "description": "If the field is a file attachment field, the name of the attached file.",
          "type": "string"
        },
        "isFile": {
          "description": "Whether the field is a file attachment.",
          "type": "boolean"
        },
        "isList": {
          "description": "Whether or not the secret field is a list.",
          "type": "boolean"
        },
        "isNotes": {
          "description": "Whether the field is represented as a multi-line text box. Used for long-form text fields.",
          "type": "boolean"
        },
        "isPassword": {
          "description": "Whether the field is a password. Password fields are hidden by default in the UI and their value is not returned in GET calls that return secrets. To retrieve a password field value, make a GET call to /api/secrets/{secretId}/fields/{slug}.",
          "type": "boolean"
        },
        "itemId": {
          "description": "The id of the secret field item. Leave empty when creating a new secret.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "itemValue": {
          "description": "The value of the secret field item. For list fields, this is a comma-delimited list of the list id guids that are assigned to this field.",
          "type": "string"
        },
        "listType": {
          "description": "The type of list. Valid values are “None”, “Generic”, and “URL”.",
          "$ref": "#/definitions/SecretFieldListType"
        },
        "slug": {
          "description": "A unique name for the secret field on the template. Slugs cannot contain spaces and are used in many places to easily refer to a secret field without having to know the field id.",
          "type": "string"
        }
      }
    },
    "RoleAssignments": {
      "description": "Roles to be assigned",
      "type": "object",
      "properties": {
        "roleIds": {
          "description": "Role IDs",
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        }
      }
    },
    "RoleChangeStatusModel": {
      "description": "The status of the Role change action.",
      "type": "object",
      "properties": {
        "success": {
          "description": "The success or failure of the user or group role action.",
          "type": "boolean"
        }
      }
    },
    "RoleCreateArgs": {
      "description": "Role create options",
      "type": "object",
      "required": [
        "name",
        "enabled"
      ],
      "properties": {
        "enabled": {
          "description": "Whether the Role is active",
          "type": "boolean"
        },
        "name": {
          "description": "Role name",
          "type": "string"
        }
      }
    },
    "RoleGroupSummary": {
      "description": "Group",
      "type": "object",
      "properties": {
        "created": {
          "description": "Created Date",
          "type": "string",
          "format": "date-time"
        },
        "displayName": {
          "description": "Group display name",
          "type": "string"
        },
        "domainName": {
          "description": "Active Directory domain name",
          "type": "string"
        },
        "enabled": {
          "description": "Whether the group is active",
          "type": "boolean"
        },
        "groupId": {
          "description": "Group ID",
          "type": "integer",
          "format": "int32"
        },
        "name": {
          "description": "Group name",
          "type": "string"
        },
        "personal": {
          "description": "Whether the group is for a single user",
          "type": "boolean"
        }
      }
    },
    "RoleGroupsPatchArgs": {
      "description": "RoleGroupsPatchArgs",
      "type": "object",
      "properties": {
        "data": {
          "description": "Data",
          "$ref": "#/definitions/RoleGroupsPatchModel"
        }
      }
    },
    "RoleGroupsPatchModel": {
      "description": "Data",
      "type": "object",
      "properties": {
        "groupIdsToAdd": {
          "description": "IDs of Groups to add to Role",
          "$ref": "#/definitions/UpdateFieldValueOfInt32"
        },
        "groupIdsToRemove": {
          "description": "IDs of Groups to remove from Role",
          "$ref": "#/definitions/UpdateFieldValueOfInt32"
        }
      }
    },
    "RoleGroupsPatchResult": {
      "description": "RoleGroupsPatchResult",
      "type": "object",
      "properties": {
        "success": {
          "description": "Success",
          "type": "boolean"
        }
      }
    },
    "RoleModel": {
      "description": "Role",
      "type": "object",
      "properties": {
        "created": {
          "description": "Created",
          "type": "string",
          "format": "date-time"
        },
        "enabled": {
          "description": "Enabled",
          "type": "boolean"
        },
        "id": {
          "description": "Role Id",
          "type": "integer",
          "format": "int32"
        },
        "isSystem": {
          "description": "Is System Role",
          "type": "boolean"
        },
        "name": {
          "description": "Name",
          "type": "string"
        }
      }
    },
    "RolePatchArgs": {
      "description": "RolePatchArgs",
      "type": "object",
      "properties": {
        "data": {
          "description": "Data",
          "$ref": "#/definitions/RolePatchModel"
        }
      }
    },
    "RolePatchModel": {
      "description": "Patch Role",
      "type": "object",
      "properties": {
        "enabled": {
          "description": "Is Role Enabled",
          "$ref": "#/definitions/UpdateFieldValueOfBoolean"
        },
        "name": {
          "description": "Name of Role",
          "$ref": "#/definitions/UpdateFieldValueOfString"
        }
      }
    },
    "RolePermissionModel": {
      "description": "Role Permission",
      "type": "object",
      "properties": {
        "name": {
          "description": "Role Name",
          "type": "string"
        },
        "rolePermissionId": {
          "description": "Role Permission ID",
          "type": "integer",
          "format": "int32"
        },
        "roleType": {
          "description": "Role Type",
          "$ref": "#/definitions/RoleTypes"
        }
      }
    },
    "RolePermissionsAssignmentRequest": {
      "description": "RolePermissionsAssignmentRequest",
      "type": "object",
      "properties": {
        "rolePermissionIds": {
          "description": "This list will be the exact RolePermissions for the Role",
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        }
      }
    },
    "RolePermissionsAssignmentResponse": {
      "description": "The status of the Role Permissions change action.",
      "type": "object",
      "properties": {
        "success": {
          "description": "The success or failure of the Role Permissions action.",
          "type": "boolean"
        }
      }
    },
    "RoleSummary": {
      "description": "Role Summary",
      "type": "object",
      "properties": {
        "name": {
          "description": "Role Name",
          "type": "string"
        },
        "roleId": {
          "description": "Role ID",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "RoleTypes": {
      "description": "Role Type",
      "type": "string",
      "enum": [
        "GlobalRoleType",
        "FolderRoleType",
        "SecretRoleType",
        "SecretTemplateRoleType",
        "ReportRoleType",
        "ReportCategoryRoleType"
      ]
    },
    "SecretAccessRequired": {
      "description": "Secret Access Required",
      "type": "string",
      "enum": [
        "None",
        "RequiresApproval",
        "RequiresCheckout",
        "RequiresComment",
        "RequiresDoubleLockPassword",
        "CreateDoubleLockPassword",
        "DoubleLockNoAccess",
        "CannotView",
        "RequiresUndelete",
        "RequiresCheckoutPendingRPC",
        "RequiresCheckoutAndComment",
        "RequiresMfaChallenge"
      ]
    },
    "SecretCreateArgs": {
      "description": "Secret create options",
      "type": "object",
      "required": [
        "name",
        "secretTemplateId",
        "items"
      ],
      "properties": {
        "autoChangeEnabled": {
          "description": "Whether the secret’s password is automatically rotated on a schedule.",
          "type": "boolean"
        },
        "changePasswordNow": {
          "description": "Whether the Secret should be immediately queued for Remote Password Change upon successful import.",
          "type": "boolean"
        },
        "checkOutChangePasswordEnabled": {
          "description": "Whether the secret’s password is automatically changed when a secret is checked in. This is a security feature that prevents a use of the password retrieved from check-out after the secret is checked in.",
          "type": "boolean"
        },
        "checkOutEnabled": {
          "description": "Whether the user must check-out the secret to view it. Checking out gives the user exclusive access to the secret for a specified period or until the secret is checked in.",
          "type": "boolean"
        },
        "checkOutIntervalMinutes": {
          "description": "The number of minutes that a secret will remain checked out.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "delayIndexing": {
          "description": "Whether the search indexing should be delayed to the background process. This can speed up bulk secret creation scripts by offloading the task of indexing the new secrets to the background task at the trade-off of not having search indexes immediately available.",
          "type": "boolean",
          "x-nullable": true
        },
        "enableInheritPermissions": {
          "description": "Whether the secret inherits permissions from the containing folder.",
          "type": "boolean",
          "x-nullable": true
        },
        "enableInheritSecretPolicy": {
          "description": "Whether the secret policy is inherited from the containing folder.",
          "type": "boolean"
        },
        "folderId": {
          "description": "If the secret is contained in a folder, the id of the containing folder. Set to null or -1 for secrets that are in the root folder.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "items": {
          "description": "An array of values for the secret fields defined in the secret template.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/RestSecretItem"
          }
        },
        "launcherConnectAsSecretId": {
          "description": "When an SSH secret is proxied, you can choose to connect as another user and then do an su to the current secret’s user. This is a common practice for connecting with a lower privileged account and then switching to the root user.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "name": {
          "description": "The name to display for the secret.",
          "type": "string"
        },
        "passwordTypeWebScriptId": {
          "description": "The id of the password change script to use on applicable web password secrets.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "proxyEnabled": {
          "description": "Whether sessions launched on this secret use Secret Server’s proxying or connect directly.",
          "type": "boolean"
        },
        "requiresComment": {
          "description": "Whether the user must enter a comment to view the secret.",
          "type": "boolean"
        },
        "secretPolicyId": {
          "description": "The id of the secret policy that controls the security and other settings of the secret. Set to null to not assign a secret policy.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "secretTemplateId": {
          "description": "The id of the secret template that defines the fields and properties of the secret.",
          "type": "integer",
          "format": "int32",
          "minimum": 1
        },
        "sessionRecordingEnabled": {
          "description": "Whether session recording is enabled.",
          "type": "boolean"
        },
        "siteId": {
          "description": "The id of the distributed engine site that is used by this secret for operations such as password changing.",
          "type": "integer",
          "format": "int32",
          "minimum": 1
        },
        "sshKeyArgs": {
          "description": "SSH key options.",
          "$ref": "#/definitions/SshKeyArgs"
        },
        "webLauncherRequiresIncognitoMode": {
          "description": "Whether the web launcher will require the browser to run in incognito mode.",
          "type": "boolean"
        }
      }
    },
    "SecretDetailActionType": {
      "description": "Secret Detail Action Type",
      "type": "string",
      "enum": [
        "ChangePasswordNow",
        "ConvertTemplate",
        "Copy",
        "Delete",
        "Edit",
        "EditExpiration",
        "EditRpc",
        "EditSecurity",
        "Expire",
        "Heartbeat",
        "EditShare",
        "ShowSshProxyCredentials",
        "StopChangePasswordNow",
        "ViewAudit",
        "ViewDependencies",
        "ViewLaunchers",
        "ViewExpiration",
        "ViewHooks",
        "ViewRpc",
        "ViewSecurity",
        "ViewSettings",
        "Undelete",
        "ForceCheckin",
        "ViewShare",
        "EditHooks",
        "EditDependencies",
        "ViewGeneralDetails",
        "ViewHeartbeatStatus",
        "Checkin",
        "Checkout",
        "GenerateOneTimePassword",
        "ShowSshTerminalDetails",
        "ShowRdpProxyCredentials",
        "ViewMetadata",
        "ViewSecretExposure",
        "ViewCheckOut",
        "ViewApproval",
        "ViewListFields",
        "Erase",
        "ViewMfa"
      ]
    },
    "SecretDetailExpirationType": {
      "description": "Expiration Type",
      "type": "string",
      "enum": [
        "Template",
        "DayInterval",
        "SpecificDate",
        "Disabled"
      ]
    },
    "SecretDetailExpirationUpdateModel": {
      "description": "Data",
      "type": "object",
      "properties": {
        "expirationDate": {
          "description": "ExpirationDate",
          "$ref": "#/definitions/UpdateFieldValueOfOptionalDateTime"
        },
        "expirationDayInterval": {
          "description": "ExpirationDayInterval",
          "$ref": "#/definitions/UpdateFieldValueOfOptionalInt32"
        },
        "expirationType": {
          "description": "ExpirationType",
          "$ref": "#/definitions/UpdateFieldValueOfSecretDetailExpirationUpdateType"
        }
      }
    },
    "SecretDetailExpirationUpdateType": {
      "description": "Value",
      "type": "string",
      "enum": [
        "Template",
        "DayInterval",
        "SpecificDate"
      ]
    },
    "SecretDetailGeneralModel": {
      "description": "Secret Detail General",
      "type": "object",
      "properties": {
        "active": {
          "description": "Whether the secret is active",
          "type": "boolean"
        },
        "autoChangePassword": {
          "description": "Whether the password should automatically change upon expiration.",
          "type": "boolean"
        },
        "canGenerateSshKey": {
          "description": "Can Generate SSH Key",
          "type": "boolean"
        },
        "enableInheritSecretPolicy": {
          "description": "Whether the secret policy is inherited from the containing folder",
          "type": "boolean"
        },
        "expiration": {
          "description": "Expiration",
          "type": "string"
        },
        "fields": {
          "description": "Secret Fields",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "folder": {
          "description": "Containing folder ID",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "heartbeatEnabled": {
          "description": "Heartbeat Enabled",
          "type": "boolean"
        },
        "id": {
          "description": "Secret Detail General Id",
          "type": "integer",
          "format": "int32"
        },
        "isFavorite": {
          "description": "Is Favorite",
          "type": "boolean"
        },
        "isOutOfSync": {
          "description": "Whether the secret is out of sync",
          "type": "boolean"
        },
        "isTotpEnabled": {
          "description": "Is One Time Password Enabled",
          "type": "boolean"
        },
        "lastHeartBeatCheck": {
          "description": "Time of last heartbeat check",
          "type": "string",
          "format": "date-time",
          "x-nullable": true
        },
        "lastHeartBeatStatus": {
          "description": "Current status of heartbeat",
          "$ref": "#/definitions/SecretDetailHeartbeatStatus"
        },
        "launchers": {
          "description": "Launchers",
          "type": "array",
          "items": {
            "$ref": "#/definitions/SecretDetailLauncher"
          }
        },
        "name": {
          "description": "Secret Detail General Name",
          "type": "string"
        },
        "outOfSyncReason": {
          "description": "Reason message if the secret is out of sync",
          "type": "string"
        },
        "secretPolicy": {
          "description": "Secret Policy",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "site": {
          "description": "Site",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "slugPrivateKey": {
          "description": "Private Key Field Slug",
          "type": "string"
        },
        "slugPublicKey": {
          "description": "Public Key Field Slug",
          "type": "string"
        },
        "template": {
          "description": "Secret template",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "totpPasswordSlug": {
          "description": "One Time Password Field Slug",
          "type": "string"
        }
      }
    },
    "SecretDetailHeartbeatStatus": {
      "description": "Current status of heartbeat",
      "type": "string",
      "enum": [
        "Failed",
        "Success",
        "Pending",
        "Disabled",
        "UnableToConnect",
        "UnknownError",
        "IncompatibleHost",
        "AccountLockedOut",
        "DnsMismatch",
        "UnableToValidateServerPublicKey",
        "Processing"
      ]
    },
    "SecretDetailLauncher": {
      "description": "Launchers",
      "type": "object",
      "properties": {
        "hasProxyCredentials": {
          "description": "HasProxyCredentials",
          "type": "boolean"
        },
        "imagePath": {
          "description": "ImagePath",
          "type": "string"
        },
        "isRecorded": {
          "description": "IsRecorded",
          "type": "boolean"
        },
        "name": {
          "description": "Name",
          "type": "string"
        },
        "showLauncher": {
          "description": "ShowLauncher",
          "type": "boolean"
        },
        "typeId": {
          "description": "TypeId",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "SecretDetailSettingsModel": {
      "description": "Secret Detail Settings",
      "type": "object",
      "properties": {
        "expirationDate": {
          "description": "Expiration Date",
          "type": "string",
          "format": "date-time",
          "x-nullable": true
        },
        "expirationDayInterval": {
          "description": "Expiration Day Interval",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "expirationTemplateText": {
          "description": "Expiration Template Text",
          "type": "string"
        },
        "expirationType": {
          "description": "Expiration Type",
          "$ref": "#/definitions/SecretDetailExpirationType"
        },
        "sendEmailWhenChanged": {
          "description": "Send Email When Changed",
          "type": "boolean"
        },
        "sendEmailWhenHeartbeatFails": {
          "description": "Send Email When Heartbeat Fails",
          "type": "boolean"
        },
        "sendEmailWhenViewed": {
          "description": "Send Email When Viewed",
          "type": "boolean"
        }
      }
    },
    "SecretDetailStateActionsModel": {
      "description": "Available Secret Detail State Actions",
      "properties": {
        "extendCheckOut": {
          "description": "The user may extend the remaining check out time of the secret.",
          "type": "boolean"
        }
      }
    },
    "SecretDetailStateViewModel": {
      "description": "Secret Detail State View Model",
      "type": "object",
      "properties": {
        "actions": {
          "description": "Allowed action for current user",
          "type": "array",
          "items": {
            "$ref": "#/definitions/SecretDetailActionType"
          }
        },
        "approvalEnd": {
          "description": "Date when the current approval expires, or null if there is no open approval",
          "type": "string",
          "format": "date-time",
          "x-nullable": true
        },
        "availableActions": {
          "description": "Secret Detail State Actions",
          "$ref": "#/definitions/SecretDetailStateActionsModel"
        },
        "checkOutIntervalMinutes": {
          "description": "Number of minutes before checkout ",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "checkOutMinutesRemaining": {
          "description": "Minutes remaining in check out",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "checkedOutUserDisplayName": {
          "description": "Display Name of User that has the secret checked out",
          "type": "string"
        },
        "checkedOutUserId": {
          "description": "User Secret is checked out to",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "folderId": {
          "description": "Folder Id",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "folderName": {
          "description": "Folder Name",
          "type": "string"
        },
        "id": {
          "description": "Secret Id",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "inheritPermissions": {
          "description": "Is this secret inheriting permissions from its folder",
          "type": "boolean"
        },
        "isActive": {
          "description": "Active indicator",
          "type": "boolean",
          "x-nullable": true
        },
        "isCheckedOut": {
          "description": "Is the Secret checked out",
          "type": "boolean",
          "x-nullable": true
        },
        "isCheckedOutByCurrentUser": {
          "description": "Indicates whether the Secret is checked out by the current user",
          "type": "boolean",
          "x-nullable": true
        },
        "passwordChangeFailed": {
          "description": "The last password change failed when true",
          "type": "boolean",
          "x-nullable": true
        },
        "passwordChangePending": {
          "description": "Pending Password change on secret indicator",
          "type": "boolean",
          "x-nullable": true
        },
        "remainingTimeWarningMinuteMarker": {
          "description": "Minute mark to show check out warning",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "role": {
          "description": "Role that current user has on Secret",
          "type": "string",
          "x-nullable": true
        },
        "secretName": {
          "description": "Secret Name",
          "type": "string"
        },
        "secretState": {
          "description": "Current State of the Secret",
          "$ref": "#/definitions/SecretAccessRequired"
        },
        "warningMinutesRemaining": {
          "description": "Minutes remaining before showing check in warning",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        }
      }
    },
    "SecretDetailUpdateExpirationArgs": {
      "description": "SecretDetailUpdateExpirationArgs",
      "type": "object",
      "properties": {
        "data": {
          "description": "Data",
          "$ref": "#/definitions/SecretDetailExpirationUpdateModel"
        }
      }
    },
    "SecretFieldListType": {
      "description": "The type of list. Valid values are “None”, “Generic”, and “URL”.",
      "type": "string",
      "enum": [
        "Generic",
        "URL",
        "None"
      ]
    },
    "SecretItemUpdateArgs": {
      "description": "Secret field update options",
      "type": "object",
      "properties": {
        "comment": {
          "description": "If the secret requires a comment to view or requires approval to view, a reason for accessing the secret must be provided.",
          "type": "string"
        },
        "doubleLockPassword": {
          "description": "If the secret is DoubleLocked, this is the DoubleLock password needed to access the secret.",
          "type": "string"
        },
        "file": {
          "description": "Uploaded file (used for file attachment fields with \"Content-Type: multipart/form-data\")",
          "type": "string"
        },
        "fileAttachment": {
          "description": "Binary file data (used for file attachment fields with \"Content-Type: application/json\")",
          "type": "string",
          "format": "binary"
        },
        "fileName": {
          "description": "File name (used for file attachment fields with \"Content-Type: application/json\"))",
          "type": "string"
        },
        "forceCheckIn": {
          "description": "Force the secret to be checked in, even if checked out by someone else. The user must have the \"Force Check In\" permission.",
          "type": "boolean"
        },
        "includeInactive": {
          "description": "If the secret is deactivated, this must be set to true in order to access the secret. The user must also have the \"View Inactive Secrets\" permission.",
          "type": "boolean"
        },
        "newPassword": {
          "description": "New secret password.",
          "type": "string"
        },
        "noAutoCheckout": {
          "description": "Don't check out the secret automatically.",
          "type": "boolean"
        },
        "ticketNumber": {
          "description": "If the secret requires a comment to view or requires approval and a user must provide a help desk a ticket number, this is the ticket number to the help desk request.",
          "type": "string"
        },
        "ticketSystemId": {
          "description": "If the secret requires a comment to view or requires approval and a user must provide a help desk a ticket number, this is the id of the help desk system configured in Secret Server that should be used to validate the ticket number.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "value": {
          "description": "New value to assign to the secret field.",
          "type": "string"
        }
      }
    },
    "SecretListFieldListArgs": {
      "description": "Secret List Field List Args",
      "type": "object",
      "properties": {
        "listGuids": {
          "description": "Array of List GUIDs",
          "type": "array",
          "items": {
            "type": "string",
            "format": "uuid"
          }
        }
      }
    },
    "SecretLookup": {
      "description": "Simple secret representation",
      "type": "object",
      "properties": {
        "id": {
          "description": "Secret ID",
          "type": "integer",
          "format": "int32"
        },
        "value": {
          "description": "Secret name",
          "type": "string"
        }
      }
    },
    "SecretModel": {
      "description": "Secret",
      "type": "object",
      "properties": {
        "accessRequestWorkflowMapId": {
          "description": "AccessRequestWorkflowMapId",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "active": {
          "description": "Whether the secret is active",
          "type": "boolean"
        },
        "allowOwnersUnrestrictedSshCommands": {
          "description": "AllowOwnersUnrestrictedSshCommands",
          "type": "boolean"
        },
        "autoChangeEnabled": {
          "description": "AutoChangeEnabled",
          "type": "boolean"
        },
        "autoChangeNextPassword": {
          "description": "AutoChangeNextPassword",
          "type": "string"
        },
        "checkOutChangePasswordEnabled": {
          "description": "CheckOutChangePasswordEnabled",
          "type": "boolean"
        },
        "checkOutEnabled": {
          "description": "Whether secret checkout is enabled",
          "type": "boolean"
        },
        "checkOutIntervalMinutes": {
          "description": "Checkout interval, in minutes",
          "type": "integer",
          "format": "int32"
        },
        "checkOutMinutesRemaining": {
          "description": "Minutes remaining in current checkout interval",
          "type": "integer",
          "format": "int32"
        },
        "checkOutUserDisplayName": {
          "description": "Name of user who has checked out the secret",
          "type": "string"
        },
        "checkOutUserId": {
          "description": "ID of user who has checked out the secret",
          "type": "integer",
          "format": "int32"
        },
        "checkedOut": {
          "description": "Whether the secret is currently checked out",
          "type": "boolean"
        },
        "doubleLockId": {
          "description": "DoubleLockId",
          "type": "integer",
          "format": "int32"
        },
        "enableInheritPermissions": {
          "description": "EnableInheritPermissions",
          "type": "boolean"
        },
        "enableInheritSecretPolicy": {
          "description": "Whether the secret policy is inherited from the containing folder",
          "type": "boolean"
        },
        "failedPasswordChangeAttempts": {
          "description": "Number of failed password change attempts",
          "type": "integer",
          "format": "int32"
        },
        "folderId": {
          "description": "Containing folder ID",
          "type": "integer",
          "format": "int32"
        },
        "id": {
          "description": "Secret ID",
          "type": "integer",
          "format": "int32"
        },
        "isDoubleLock": {
          "description": "Whether double lock is enabled",
          "type": "boolean"
        },
        "isOutOfSync": {
          "description": "Out of sync indicates that a Password is setup for autochange and has failed its last password change attempt or has exceeded the maximum RPC attempts",
          "type": "boolean"
        },
        "isRestricted": {
          "description": "Whether the secret is restricted",
          "type": "boolean"
        },
        "items": {
          "description": "Secret data fields",
          "type": "array",
          "items": {
            "$ref": "#/definitions/RestSecretItem"
          }
        },
        "jumpboxRouteId": {
          "description": "JumpboxRouteId",
          "type": "string",
          "format": "uuid",
          "x-nullable": true
        },
        "lastHeartBeatCheck": {
          "description": "Time of last heartbeat check",
          "type": "string",
          "format": "date-time"
        },
        "lastHeartBeatStatus": {
          "description": "Current status of heartbeat",
          "$ref": "#/definitions/HeartbeatStatus"
        },
        "lastPasswordChangeAttempt": {
          "description": "Time of most recent password change attempt",
          "type": "string",
          "format": "date-time"
        },
        "launcherConnectAsSecretId": {
          "description": "LauncherConnectAsSecretId",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "name": {
          "description": "Secret name",
          "type": "string"
        },
        "outOfSyncReason": {
          "description": "Reason message if the secret is out of sync",
          "type": "string"
        },
        "passwordTypeWebScriptId": {
          "description": "PasswordTypeWebScriptId",
          "type": "integer",
          "format": "int32"
        },
        "proxyEnabled": {
          "description": "ProxyEnabled",
          "type": "boolean"
        },
        "requiresApprovalForAccess": {
          "description": "RequiresApprovalForAccess",
          "type": "boolean"
        },
        "requiresComment": {
          "description": "RequiresComment",
          "type": "boolean"
        },
        "responseCodes": {
          "description": "ResponseCodes",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "restrictSshCommands": {
          "description": "RestrictSshCommands",
          "type": "boolean"
        },
        "secretPolicyId": {
          "description": "SecretPolicyId",
          "type": "integer",
          "format": "int32"
        },
        "secretTemplateId": {
          "description": "Secret template ID",
          "type": "integer",
          "format": "int32"
        },
        "secretTemplateName": {
          "description": "Name of secret template",
          "type": "string"
        },
        "sessionRecordingEnabled": {
          "description": "Whether session recording is enabled",
          "type": "boolean"
        },
        "siteId": {
          "description": "SiteId",
          "type": "integer",
          "format": "int32"
        },
        "webLauncherRequiresIncognitoMode": {
          "description": "WebLauncherRequiresIncognitoMode",
          "type": "boolean"
        }
      }
    },
    "SecretModelV2": {
      "description": "Secret V2",
      "type": "object",
      "properties": {
        "accessRequestWorkflowMapId": {
          "description": "Access Request Workflow Map Id",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "active": {
          "description": "Whether the secret is active",
          "type": "boolean"
        },
        "allowOwnersUnrestrictedSshCommands": {
          "description": "Allow Owners Unrestricted SSH Commands",
          "type": "boolean"
        },
        "autoChangeEnabled": {
          "description": "Auto Change Enabled",
          "type": "boolean"
        },
        "autoChangeNextPassword": {
          "description": "Auto Change Next Password",
          "type": "string"
        },
        "checkOutChangePasswordEnabled": {
          "description": "Check Out Change Password Enabled",
          "type": "boolean"
        },
        "checkOutEnabled": {
          "description": "Whether secret checkout is enabled",
          "type": "boolean"
        },
        "checkOutIntervalMinutes": {
          "description": "Checkout interval, in minutes",
          "type": "integer",
          "format": "int32"
        },
        "checkOutMinutesRemaining": {
          "description": "Minutes remaining in current checkout interval",
          "type": "integer",
          "format": "int32"
        },
        "checkOutUserDisplayName": {
          "description": "Name of user who has checked out the secret",
          "type": "string"
        },
        "checkOutUserId": {
          "description": "ID of user who has checked out the secret",
          "type": "integer",
          "format": "int32"
        },
        "checkedOut": {
          "description": "Whether the secret is currently checked out",
          "type": "boolean"
        },
        "doubleLockId": {
          "description": "DoubleLock Id",
          "type": "integer",
          "format": "int32"
        },
        "enableInheritPermissions": {
          "description": "Enable Inherit Permissions",
          "type": "boolean"
        },
        "enableInheritSecretPolicy": {
          "description": "Whether the secret policy is inherited from the containing folder",
          "type": "boolean"
        },
        "failedPasswordChangeAttempts": {
          "description": "Number of failed password change attempts",
          "type": "integer",
          "format": "int32"
        },
        "folderId": {
          "description": "Containing folder ID",
          "type": "integer",
          "format": "int32"
        },
        "id": {
          "description": "Secret ID",
          "type": "integer",
          "format": "int32"
        },
        "isDoubleLock": {
          "description": "Whether double lock is enabled",
          "type": "boolean"
        },
        "isOutOfSync": {
          "description": "Out of sync indicates that a Password is setup for autochange and has failed its last password change attempt or has exceeded the maximum RPC attempts",
          "type": "boolean"
        },
        "isRestricted": {
          "description": "Whether the secret is restricted",
          "type": "boolean"
        },
        "items": {
          "description": "Secret data fields",
          "type": "array",
          "items": {
            "$ref": "#/definitions/RestSecretItem"
          }
        },
        "jumpboxRouteId": {
          "description": "Jumpbox Route Id",
          "type": "string",
          "format": "uuid",
          "x-nullable": true
        },
        "lastHeartBeatCheck": {
          "description": "Time of last heartbeat check",
          "type": "string",
          "format": "date-time",
          "x-nullable": true
        },
        "lastHeartBeatStatus": {
          "description": "Current status of heartbeat",
          "$ref": "#/definitions/HeartbeatStatus"
        },
        "lastPasswordChangeAttempt": {
          "description": "Time of most recent password change attempt",
          "type": "string",
          "format": "date-time",
          "x-nullable": true
        },
        "launcherConnectAsSecretId": {
          "description": "LauncherConnectAsSecretId",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "name": {
          "description": "Secret name",
          "type": "string"
        },
        "outOfSyncReason": {
          "description": "Reason message if the secret is out of sync",
          "type": "string"
        },
        "passwordTypeWebScriptId": {
          "description": "Password Type Web Script Id",
          "type": "integer",
          "format": "int32"
        },
        "proxyEnabled": {
          "description": "Proxy Enabled",
          "type": "boolean"
        },
        "requiresApprovalForAccess": {
          "description": "Requires Approval For Access",
          "type": "boolean"
        },
        "requiresComment": {
          "description": "Requires Comment",
          "type": "boolean"
        },
        "responseCodes": {
          "description": "Response Codes",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "restrictSshCommands": {
          "description": "Restrict SSH Commands",
          "type": "boolean"
        },
        "secretPolicyId": {
          "description": "Secret Policy Id",
          "type": "integer",
          "format": "int32"
        },
        "secretTemplateId": {
          "description": "Secret template ID",
          "type": "integer",
          "format": "int32"
        },
        "secretTemplateName": {
          "description": "Name of secret template",
          "type": "string"
        },
        "sessionRecordingEnabled": {
          "description": "Whether session recording is enabled",
          "type": "boolean"
        },
        "siteId": {
          "description": "Site Id",
          "type": "integer",
          "format": "int32"
        },
        "webLauncherRequiresIncognitoMode": {
          "description": "Web Launcher Requires Incognito Mode",
          "type": "boolean"
        }
      }
    },
    "SecretRestrictedArgs": {
      "description": "Restricted secret update options",
      "type": "object",
      "properties": {
        "comment": {
          "description": "If the secret requires a comment to view or requires approval to view, a reason for accessing the secret must be provided.",
          "type": "string"
        },
        "doubleLockPassword": {
          "description": "If the secret is DoubleLocked, this is the DoubleLock password needed to access the secret.",
          "type": "string"
        },
        "forceCheckIn": {
          "description": "Force the secret to be checked in, even if checked out by someone else. The user must have the \"Force Check In\" permission.",
          "type": "boolean"
        },
        "includeInactive": {
          "description": "If the secret is deactivated, this must be set to true in order to access the secret. The user must also have the \"View Inactive Secrets\" permission.",
          "type": "boolean"
        },
        "newPassword": {
          "description": "New secret password.",
          "type": "string"
        },
        "noAutoCheckout": {
          "description": "Don't check out the secret automatically.",
          "type": "boolean"
        },
        "ticketNumber": {
          "description": "If the secret requires a comment to view or requires approval and a user must provide a help desk a ticket number, this is the ticket number to the help desk request.",
          "type": "string"
        },
        "ticketSystemId": {
          "description": "If the secret requires a comment to view or requires approval and a user must provide a help desk a ticket number, this is the id of the help desk system configured in Secret Server that should be used to validate the ticket number.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        }
      }
    },
    "SecretSearchExtendedArgs": {
      "description": "SecretSearchExtendedArgs",
      "type": "object",
      "properties": {
        "data": {
          "description": "Data",
          "$ref": "#/definitions/SecretSearchExtendedData"
        }
      }
    },
    "SecretSearchExtendedData": {
      "description": "Data",
      "type": "object",
      "properties": {
        "secretIds": {
          "description": "Pass an array of secret IDs to get back settings on these secrets for the current user",
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        }
      }
    },
    "SecretSearchExtendedSummary": {
      "description": "SecretSearchExtendedSummary[]",
      "type": "object",
      "properties": {
        "hasLaunchers": {
          "description": "Does this Secret have launchers the current user can use",
          "type": "boolean"
        },
        "isFavorite": {
          "description": "Is this a favorite secret for the current user",
          "type": "boolean"
        },
        "lastAccessed": {
          "description": "Does this Secret have launchers the current user can use",
          "type": "string",
          "format": "date-time",
          "x-nullable": true
        },
        "secretId": {
          "description": "Secret ID",
          "type": "integer",
          "format": "int32"
        },
        "secretName": {
          "description": "Secret Name",
          "type": "string"
        },
        "totalSecretViews": {
          "description": "Does this Secret have launchers the current user can use",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "SecretSummary": {
      "description": "Secret summary",
      "type": "object",
      "properties": {
        "active": {
          "description": "Whether the secret is active",
          "type": "boolean"
        },
        "autoChangeEnabled": {
          "description": "Indicates whether or not this Secret an auto changing password",
          "type": "boolean",
          "x-nullable": true
        },
        "checkOutEnabled": {
          "description": "Indicates whether or not checkout is enabled for the Secret",
          "type": "boolean",
          "x-nullable": true
        },
        "checkOutUserId": {
          "description": "Id of the User that has the secret checked out if it is checked out",
          "type": "integer",
          "format": "int32"
        },
        "checkOutUserName": {
          "description": "The name of the User that has the secret checked out if it is checked out",
          "type": "string"
        },
        "checkedOut": {
          "description": "Whether the secret is currently checked out",
          "type": "boolean"
        },
        "createDate": {
          "description": "When the Secret was created",
          "type": "string",
          "format": "date-time",
          "x-nullable": true
        },
        "daysUntilExpiration": {
          "description": "How many days until this Secret expires",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "doubleLockEnabled": {
          "description": "Indicates whether or not DoubleLock is enabled for this password",
          "type": "boolean",
          "x-nullable": true
        },
        "extendedFields": {
          "description": "Any requested extended fields from a lookup request",
          "type": "array",
          "items": {
            "$ref": "#/definitions/ISecretSummaryExtendedField"
          }
        },
        "folderId": {
          "description": "Containing folder ID",
          "type": "integer",
          "format": "int32"
        },
        "folderPath": {
          "description": "Containing folder path",
          "type": "string"
        },
        "hasLauncher": {
          "description": "Indicates if this Secret has any launchers",
          "type": "boolean"
        },
        "hidePassword": {
          "description": "Indicates if the launcher password is set to be hidden",
          "type": "boolean",
          "x-nullable": true
        },
        "id": {
          "description": "Secret ID",
          "type": "integer",
          "format": "int32"
        },
        "inheritsPermissions": {
          "description": "Indicates if this Secret inherits permissions from its folder",
          "type": "boolean",
          "x-nullable": true
        },
        "isOutOfSync": {
          "description": "Indicates that Heartbeat has failed or a Password is set up for autochange and has failed its last password change attempt or has exceeded the maximum RPC attempts",
          "type": "boolean"
        },
        "isRestricted": {
          "description": "Whether the secret is restricted",
          "type": "boolean"
        },
        "lastAccessed": {
          "description": "When the Secret was last viewed by the current User",
          "type": "string",
          "format": "date-time",
          "x-nullable": true
        },
        "lastHeartBeatStatus": {
          "description": "Current status of heartbeat",
          "$ref": "#/definitions/HeartbeatStatus"
        },
        "lastPasswordChangeAttempt": {
          "description": "Time of most recent password change attempt",
          "type": "string",
          "format": "date-time",
          "x-nullable": true
        },
        "name": {
          "description": "Secret name",
          "type": "string"
        },
        "outOfSyncReason": {
          "description": "Reason message if the secret is out of sync",
          "type": "string"
        },
        "requiresApproval": {
          "description": "Indicates if this Secret requires approval",
          "type": "boolean",
          "x-nullable": true
        },
        "requiresComment": {
          "description": "Indicates if this Secret requires comment",
          "type": "boolean",
          "x-nullable": true
        },
        "responseCodes": {
          "description": "ResponseCodes",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "secretTemplateId": {
          "description": "Secret template ID",
          "type": "integer",
          "format": "int32"
        },
        "secretTemplateName": {
          "description": "Name of secret template",
          "type": "string"
        },
        "siteId": {
          "description": "SiteId",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "SecretUpdateArgs": {
      "description": "Secret update options",
      "type": "object",
      "required": [
        "id",
        "name",
        "items"
      ],
      "properties": {
        "accessRequestWorkflowMapId": {
          "description": "The id of the mapping entity that associates this secret to a specific access request workflow.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "active": {
          "description": "Whether the secret is in an active or deleted state.",
          "type": "boolean"
        },
        "autoChangeEnabled": {
          "description": "Whether the secret’s password is automatically rotated on a schedule.",
          "type": "boolean"
        },
        "autoChangeNextPassword": {
          "description": "Whether the secret should be flagged for immediate password change.",
          "type": "string"
        },
        "checkOutChangePasswordEnabled": {
          "description": "Whether the secret’s password is automatically changed when a secret is checked in. This is a security feature that prevents a use of the password retrieved from check-out after the secret is checked in.",
          "type": "boolean"
        },
        "checkOutEnabled": {
          "description": "Whether the user must check-out the secret to view it. Checking out gives the user exclusive access to the secret for a specified period or until the secret is checked in.",
          "type": "boolean"
        },
        "checkOutIntervalMinutes": {
          "description": "The number of minutes that a secret will remain checked out.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "comment": {
          "description": "If the secret requires a comment to view or requires approval to view, a reason for accessing the secret must be provided.",
          "type": "string"
        },
        "doubleLockPassword": {
          "description": "If the secret is DoubleLocked, this is the DoubleLock password needed to access the secret.",
          "type": "string"
        },
        "enableInheritPermissions": {
          "description": "Whether the secret inherits permissions from the containing folder.",
          "type": "boolean",
          "x-nullable": true
        },
        "enableInheritSecretPolicy": {
          "description": "Whether the secret policy is inherited from the containing folder.",
          "type": "boolean"
        },
        "folderId": {
          "description": "If the secret is contained in a folder, the id of the containing folder. Set to null or -1 for secrets that are in the root folder.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "forceCheckIn": {
          "description": "Force the secret to be checked in, even if checked out by someone else. The user must have the \"Force Check In\" permission.",
          "type": "boolean"
        },
        "id": {
          "description": "The id of the Secret to update. Must match the {id} in the path.",
          "type": "integer",
          "format": "int32",
          "minimum": 1
        },
        "includeInactive": {
          "description": "If the secret is deactivated, this must be set to true in order to access the secret. The user must also have the \"View Inactive Secrets\" permission.",
          "type": "boolean"
        },
        "items": {
          "description": "A list of secret item field values.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/RestSecretItem"
          }
        },
        "launcherConnectAsSecretId": {
          "description": "When an SSH secret is proxied, you can choose to connect as another user and then do an su to the current secret’s user. This is a common practice for connecting with a lower privileged account and then switching to the root user.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "name": {
          "description": "The name to display for the secret.",
          "type": "string"
        },
        "newPassword": {
          "description": "New secret password.",
          "type": "string"
        },
        "noAutoCheckout": {
          "description": "Don't check out the secret automatically.",
          "type": "boolean"
        },
        "passwordTypeWebScriptId": {
          "description": "The id of the password change script to use on applicable web password secrets.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "proxyEnabled": {
          "description": "Whether sessions launched on this secret use Secret Server’s proxying or connect directly.",
          "type": "boolean"
        },
        "requiresComment": {
          "description": "Whether the user must enter a comment to view the secret.",
          "type": "boolean"
        },
        "secretPolicyId": {
          "description": "The id of the secret policy that controls the security and other settings of the secret. Set to null to not assign a secret policy.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "sessionRecordingEnabled": {
          "description": "Whether session recording is enabled.",
          "type": "boolean"
        },
        "siteId": {
          "description": "The id of the distributed engine site that is used by this secret for operations such as password changing.",
          "type": "integer",
          "format": "int32",
          "minimum": 1
        },
        "sshKeyArgs": {
          "description": "SSH key options",
          "$ref": "#/definitions/SshKeyArgs"
        },
        "ticketNumber": {
          "description": "If the secret requires a comment to view or requires approval and a user must provide a help desk a ticket number, this is the ticket number to the help desk request.",
          "type": "string"
        },
        "ticketSystemId": {
          "description": "If the secret requires a comment to view or requires approval and a user must provide a help desk a ticket number, this is the id of the help desk system configured in Secret Server that should be used to validate the ticket number.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "webLauncherRequiresIncognitoMode": {
          "description": "Whether the web launcher will require the browser to run in incognito mode.",
          "type": "boolean",
          "x-nullable": true
        }
      }
    },
    "Severity": {
      "description": "Error severity level",
      "type": "string",
      "enum": [
        "None",
        "Retry",
        "Warn",
        "Critical",
        "Fatal"
      ]
    },
    "Sort": {
      "description": "Sort options. Multiple sort options can be provided in the query string.",
      "type": "object",
      "required": [
        "name",
        "direction"
      ],
      "properties": {
        "direction": {
          "description": "Sort direction",
          "$ref": "#/definitions/SortDirection"
        },
        "name": {
          "description": "Sort field name",
          "type": "string"
        },
        "priority": {
          "description": "Priority index. Sorts with lower values are executed earlier",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "SortDirection": {
      "description": "Sort direction",
      "type": "string",
      "enum": [
        "None",
        "Asc",
        "Desc"
      ]
    },
    "SshKeyArgs": {
      "description": "SSH key options",
      "type": "object",
      "properties": {
        "generatePassphrase": {
          "description": "Whether to generate an SSH private key passphrase.  Only applicable when the Secret template has a password changer with the Private Key Passphrase field mapped.  If it is not mapped, this setting is ignored.",
          "type": "boolean"
        },
        "generateSshKeys": {
          "description": "Whether to generate an SSH private key",
          "type": "boolean"
        }
      }
    },
    "TokenErrorResponse": {
      "description": "API access token error response",
      "type": "object",
      "required": [
        "message"
      ],
      "properties": {
        "message": {
          "description": "Authentication token",
          "type": "string"
        }
      }
    },
    "TokenResponse": {
      "description": "API access token response",
      "type": "object",
      "required": [
        "access_token",
        "token_type",
        "expires_in"
      ],
      "properties": {
        "access_token": {
          "description": "Authentication token",
          "type": "string"
        },
        "expires_in": {
          "description": "Authentication token expiration time, in seconds",
          "type": "string"
        },
        "refresh_token": {
          "description": "Refresh token.  This is only provided when the server is set to allow refresh tokens for web services and when the session timeout duration is not set to Unlimited.",
          "type": "string"
        },
        "token_type": {
          "description": "Authentication token type",
          "type": "string",
          "enum": [
            "bearer"
          ]
        }
      }
    },
    "UpdateFieldValueOfBoolean": {
      "description": "Active",
      "type": "object",
      "properties": {
        "dirty": {
          "description": "Dirty",
          "type": "boolean"
        },
        "value": {
          "description": "Value",
          "type": "boolean"
        }
      }
    },
    "UpdateFieldValueOfInt32": {
      "description": "FolderIds",
      "type": "object",
      "properties": {
        "dirty": {
          "description": "Dirty",
          "type": "boolean"
        },
        "value": {
          "description": "Value",
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        }
      }
    },
    "UpdateFieldValueOfOptionalDateTime": {
      "description": "Update when the pinned folder was last viewed",
      "type": "object",
      "properties": {
        "dirty": {
          "description": "Dirty",
          "type": "boolean"
        },
        "value": {
          "description": "Value",
          "type": "string",
          "format": "date-time",
          "x-nullable": true
        }
      }
    },
    "UpdateFieldValueOfOptionalInt32": {
      "description": "The minimum length required for local user passwords",
      "type": "object",
      "properties": {
        "dirty": {
          "description": "Dirty",
          "type": "boolean"
        },
        "value": {
          "description": "Value",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        }
      }
    },
    "UpdateFieldValueOfSecretDetailExpirationUpdateType": {
      "description": "ExpirationType",
      "type": "object",
      "properties": {
        "dirty": {
          "description": "Dirty",
          "type": "boolean"
        },
        "value": {
          "description": "Value",
          "$ref": "#/definitions/SecretDetailExpirationUpdateType"
        }
      }
    },
    "UpdateFieldValueOfString": {
      "description": "Description",
      "type": "object",
      "properties": {
        "dirty": {
          "description": "Dirty",
          "type": "boolean"
        },
        "value": {
          "description": "Value",
          "type": "string"
        }
      }
    },
    "UserIpAddressRestrictionModel": {
      "description": "UserIpAddressRestrictionModel",
      "type": "object",
      "properties": {
        "id": {
          "description": "Id",
          "type": "integer",
          "format": "int32"
        },
        "ipAddressRestrictionId": {
          "description": "IpAddressRestrictionId",
          "type": "integer",
          "format": "int32"
        },
        "ipAddressRestrictionName": {
          "description": "IpAddressRestrictionName",
          "type": "string"
        },
        "userDisplayName": {
          "description": "UserDisplayName",
          "type": "string"
        },
        "userId": {
          "description": "UserId",
          "type": "integer",
          "format": "int32"
        },
        "userName": {
          "description": "UserName",
          "type": "string"
        }
      }
    },
    "UserLookup": {
      "description": "Simple user representation",
      "type": "object",
      "properties": {
        "id": {
          "description": "User ID",
          "type": "integer",
          "format": "int32"
        },
        "value": {
          "description": "User name",
          "type": "string"
        }
      }
    },
    "UserModel": {
      "description": "User",
      "type": "object",
      "properties": {
        "adAccountExpires": {
          "description": "Active Directory account expiration time",
          "type": "string",
          "format": "date-time"
        },
        "adGuid": {
          "description": "Active Directory unique identifier",
          "type": "string"
        },
        "created": {
          "description": "User creation time",
          "type": "string",
          "format": "date-time"
        },
        "dateOptionId": {
          "description": "DateOptionId",
          "type": "integer",
          "format": "int32"
        },
        "displayName": {
          "description": "Display name",
          "type": "string"
        },
        "domainId": {
          "description": "Active Directory domain ID",
          "type": "integer",
          "format": "int32"
        },
        "duoTwoFactor": {
          "description": "Whether Duo two-factor authentication is enabled",
          "type": "boolean"
        },
        "emailAddress": {
          "description": "Email address",
          "type": "string"
        },
        "enabled": {
          "description": "Whether the user account is enabled",
          "type": "boolean"
        },
        "fido2TwoFactor": {
          "description": "Whether FIDO2 two-factor authentication is enabled",
          "type": "boolean"
        },
        "id": {
          "description": "User ID",
          "type": "integer",
          "format": "int32"
        },
        "ipAddressRestrictions": {
          "description": "Array of IP Address Restrictions for the user.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UserIpAddressRestrictionModel"
          }
        },
        "isApplicationAccount": {
          "description": "IsApplicationAccount",
          "type": "boolean"
        },
        "isEmailCopiedFromAD": {
          "description": "Whether the email address is derived from the Active Directory account",
          "type": "boolean"
        },
        "isEmailVerified": {
          "description": "Whether the email address has been verified",
          "type": "boolean"
        },
        "isLockedOut": {
          "description": "Whether the user is locked out",
          "type": "boolean"
        },
        "lastLogin": {
          "description": "Time of last login",
          "type": "string",
          "format": "date-time"
        },
        "lastSessionActivity": {
          "description": "Time of last session activity",
          "type": "string",
          "format": "date-time",
          "x-nullable": true
        },
        "lockOutReason": {
          "description": "The reason for the lock out",
          "type": "string",
          "x-nullable": true
        },
        "lockOutReasonDescription": {
          "description": "An optional description of the reason for the lock out",
          "type": "string"
        },
        "loginFailures": {
          "description": "Number of login failures",
          "type": "integer",
          "format": "int32"
        },
        "mustVerifyEmail": {
          "description": "Whether the user must verify their email address",
          "type": "boolean"
        },
        "oathTwoFactor": {
          "description": "Whether OATH two-factor authentication is enabled",
          "type": "boolean"
        },
        "oathVerified": {
          "description": "Whether OATH has been verified",
          "type": "boolean"
        },
        "passwordLastChanged": {
          "description": "Time when the password was last changed",
          "type": "string",
          "format": "date-time"
        },
        "personalGroupId": {
          "description": "The personal group ID for this user.  Each user has a personal group that is a group that only contains that user.",
          "type": "integer",
          "format": "int32"
        },
        "radiusTwoFactor": {
          "description": "Whether RADIUS two-factor authentication is enabled",
          "type": "boolean"
        },
        "radiusUserName": {
          "description": "RADIUS username",
          "type": "string"
        },
        "resetSessionStarted": {
          "description": "ResetSessionStarted",
          "type": "string",
          "format": "date-time"
        },
        "slackId": {
          "description": "Slack ID of the user",
          "type": "string"
        },
        "timeOptionId": {
          "description": "TimeOptionId",
          "type": "integer",
          "format": "int32"
        },
        "twoFactor": {
          "description": "Whether two-factor authentication is enabled",
          "type": "boolean"
        },
        "userLcid": {
          "description": "UserLcid",
          "type": "integer",
          "format": "int32"
        },
        "userName": {
          "description": "User name",
          "type": "string"
        },
        "verifyEmailSentDate": {
          "description": "Time when the verification email was sent",
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "UserRoleSummary": {
      "description": "All of the roles a user has",
      "type": "object",
      "properties": {
        "groups": {
          "description": "All of the groups to which the user belongs that have this role",
          "type": "array",
          "items": {
            "$ref": "#/definitions/GroupAssignedRoleModel"
          }
        },
        "isDirectAssignment": {
          "description": "Is the role directly assigned to the user",
          "type": "boolean"
        },
        "roleId": {
          "description": "Role ID",
          "type": "integer",
          "format": "int32"
        },
        "roleName": {
          "description": "Role Name",
          "type": "string"
        }
      }
    },
    "UserUpdateArgs": {
      "description": "User update options",
      "type": "object",
      "properties": {
        "dateOptionId": {
          "description": "The id of the date format to use when displaying dates to this user. These options are defined in Admin \u003e Configuration.",
          "type": "integer",
          "format": "int32"
        },
        "displayName": {
          "description": "The user’s name as displayed in the user interface.",
          "type": "string"
        },
        "duoTwoFactor": {
          "description": "Whether Duo two-factor authentication is enabled.",
          "type": "boolean"
        },
        "emailAddress": {
          "description": "The user's email address. Used by the system to send reports, access requests, and other notifications.",
          "type": "string"
        },
        "enabled": {
          "description": "Whether the user account is enabled. Disabled users are unable to log in and do not consume a user license.",
          "type": "boolean"
        },
        "fido2TwoFactor": {
          "description": "Whether FIDO2 two-factor authentication is enabled.",
          "type": "boolean"
        },
        "groupOwners": {
          "description": "A list of group ids for the groups that can manage this user. If not set, the user is managed by all users with the ‘Administer Users’ role permission.",
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        },
        "id": {
          "description": "User ID. Must match ID in path.",
          "type": "integer",
          "format": "int32",
          "minimum": 1
        },
        "isApplicationAccount": {
          "description": "Whether this is an application account. Application accounts are used for automation, cannot log in using the UI, and do not consume a user license.",
          "type": "boolean"
        },
        "isGroupOwnerUpdate": {
          "description": "Whether the user is managed by the groups specified in GroupOwners or is managed by all users with the ‘Administer Users’ role permission.",
          "type": "boolean"
        },
        "isLockedOut": {
          "description": "Whether the user is locked out. A locked out user cannot log in.",
          "type": "boolean"
        },
        "loginFailures": {
          "description": "Number of login failures to allow before the account is locked out. Set to 0 for unlimited login attempts.",
          "type": "integer",
          "format": "int32"
        },
        "oathTwoFactor": {
          "description": "Whether OATH two-factor authentication is enabled.",
          "type": "boolean"
        },
        "password": {
          "description": "The password used by local accounts to log in.",
          "type": "string"
        },
        "radiusTwoFactor": {
          "description": "Whether RADIUS two-factor authentication is enabled.",
          "type": "boolean"
        },
        "radiusUserName": {
          "description": "When a user account uses RADIUS two-factor authentication, this property is the user name of the RADIUS account used to authenticate this user.",
          "type": "string"
        },
        "timeOptionId": {
          "description": "The id of the time format to use when displaying times to this user. These options are defined in Admin \u003e Configuration.",
          "type": "integer",
          "format": "int32"
        },
        "twoFactor": {
          "description": "Whether two-factor authentication is enabled.",
          "type": "boolean"
        }
      }
    }
  },
  "securityDefinitions": {
    "Bearer": {
      "type": "apiKey",
      "name": "Authorization",
      "in": "header"
    }
  },
  "tags": [
    {
      "description": "Authenticate against Secret Server and acquire a token for other API requests",
      "name": "Authentication"
    },
    {
      "description": "View and maintain Secrets",
      "name": "Secrets"
    }
  ]
}`))
	FlatSwaggerJSON = json.RawMessage([]byte(`{
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "schemes": [
    "http",
    "https"
  ],
  "swagger": "2.0",
  "info": {
    "description": "REST API documentation for Secret Server. This document describes how to use the REST API. All requests require an authentication token; please see the \u003ca href=\"../OAuth/\"\u003eauthentication document\u003c/a\u003e for more information. The \u003ca href=\"swagger.json\"\u003eSwagger specification\u003c/a\u003e for this API is also available.",
    "title": "Secret Server Rest API",
    "termsOfService": "https://delinea.com/eula",
    "contact": {
      "name": "Support",
      "url": "https://delinea.com"
    },
    "version": "11.7.2"
  },
  "basePath": "/SecretServer",
  "paths": {
    "/api/v1/roles": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Search, filter, sort, and page Roles",
        "tags": [
          "Roles"
        ],
        "summary": "Search Roles",
        "operationId": "RolesService_GetAll",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "Only return roles assigned to this group id.  Will be ignored if UserId is set",
            "name": "filter.groupId",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to include inactive Roles in the results",
            "name": "filter.includeInactive",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "Only return roles assigned to this user id.  Will supercede GroupId if set",
            "name": "filter.userId",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Number of records to skip before taking results",
            "name": "skip",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort direction",
            "name": "sortBy[0].direction",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort field name",
            "name": "sortBy[0].name",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Priority index. Sorts with lower values are executed earlier",
            "name": "sortBy[0].priority",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Maximum number of records to include in results",
            "name": "take",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Role search result object",
            "schema": {
              "$ref": "#/definitions/PagingOfRoleModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      },
      "post": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Create a new Role",
        "tags": [
          "Roles"
        ],
        "summary": "Create Role",
        "operationId": "RolesService_Create",
        "parameters": [
          {
            "description": "args",
            "name": "args",
            "in": "body",
            "schema": {
              "description": "args",
              "$ref": "#/definitions/RoleCreateArgs"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Role object",
            "schema": {
              "$ref": "#/definitions/RoleModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/roles/stub": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Return the default values for a new Role",
        "tags": [
          "Roles"
        ],
        "summary": "Get Role Stub",
        "operationId": "RolesService_Stub",
        "responses": {
          "200": {
            "description": "Role object",
            "schema": {
              "$ref": "#/definitions/RoleModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/roles/{id}": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Get Role by Role ID",
        "tags": [
          "Roles"
        ],
        "summary": "Get Role",
        "operationId": "RolesService_Get",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Role model result object",
            "schema": {
              "$ref": "#/definitions/RoleModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      },
      "patch": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Update a single Role by ID",
        "tags": [
          "Roles"
        ],
        "summary": "Update Role",
        "operationId": "RolesService_Update",
        "parameters": [
          {
            "description": "Role update options",
            "name": "args",
            "in": "body",
            "schema": {
              "description": "Role update options",
              "$ref": "#/definitions/RolePatchArgs"
            }
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Role ID",
            "name": "id",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Role object",
            "schema": {
              "$ref": "#/definitions/RoleModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/roles/{id}/groups": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Get assigned Groups by RoleId",
        "tags": [
          "Roles"
        ],
        "summary": "Get Role Groups",
        "operationId": "RolesService_GetRoleGroups",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "boolean",
            "description": "Whether to include inactive users in the results",
            "name": "filter.includeInactiveUsersForGroup",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "Filter only users in a specific domain",
            "name": "filter.userDomainId",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Number of records to skip before taking results",
            "name": "skip",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort direction",
            "name": "sortBy[0].direction",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort field name",
            "name": "sortBy[0].name",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Priority index. Sorts with lower values are executed earlier",
            "name": "sortBy[0].priority",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Maximum number of records to include in results",
            "name": "take",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Role Group summary result object",
            "schema": {
              "$ref": "#/definitions/PagingOfRoleGroupSummaryAndGroupMembershipFilter"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/roles/{id}/permissions": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Get Permissions assigned to a single Role by Role ID",
        "tags": [
          "Roles"
        ],
        "summary": "Get Assigned Role Permissions",
        "operationId": "RolesService_GetRolePermissions",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Number of records to skip before taking results",
            "name": "skip",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort direction",
            "name": "sortBy[0].direction",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort field name",
            "name": "sortBy[0].name",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Priority index. Sorts with lower values are executed earlier",
            "name": "sortBy[0].priority",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Maximum number of records to include in results",
            "name": "take",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Role Permission model result object",
            "schema": {
              "$ref": "#/definitions/PagingOfRolePermissionModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      },
      "put": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Update all Permissions assigned to Role",
        "tags": [
          "Roles"
        ],
        "summary": "Update Role Permission Assignments",
        "operationId": "RolesService_UpdatePermissions",
        "parameters": [
          {
            "description": "args",
            "name": "args",
            "in": "body",
            "schema": {
              "description": "args",
              "$ref": "#/definitions/RolePermissionsAssignmentRequest"
            }
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success / Fail",
            "schema": {
              "$ref": "#/definitions/RolePermissionsAssignmentResponse"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/roles/{id}/permissions/unassigned": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Get unassigned Role Permissions matching the type of a specific Role by Role ID",
        "tags": [
          "Roles"
        ],
        "summary": "Get Unassigned Role Permissions",
        "operationId": "RolesService_GetAllRolePermissionsByType",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Number of records to skip before taking results",
            "name": "skip",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort direction",
            "name": "sortBy[0].direction",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort field name",
            "name": "sortBy[0].name",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Priority index. Sorts with lower values are executed earlier",
            "name": "sortBy[0].priority",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Maximum number of records to include in results",
            "name": "take",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Role model result object",
            "schema": {
              "$ref": "#/definitions/PagingOfRolePermissionModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/roles/{roleId}/groups": {
      "patch": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Update Groups assigned to a Role by sending list(s) of Group IDs to add/remove",
        "tags": [
          "Roles"
        ],
        "summary": "Patch Role Group Assignments",
        "operationId": "RolesService_PatchGroups",
        "parameters": [
          {
            "description": "Role Groups update options",
            "name": "args",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/RoleGroupsPatchArgs"
            }
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Role ID",
            "name": "roleId",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Role object",
            "schema": {
              "$ref": "#/definitions/RoleGroupsPatchResult"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Search, filter, sort, and page secrets (removed from 11.3.3, but exposed for completeness)",
        "tags": [
          "Secrets"
        ],
        "summary": "Search Secrets",
        "operationId": "SecretsService_Search",
        "parameters": [
          {
            "type": "boolean",
            "description": "Whether to allow DoubleLocks as part of the search. True by default.",
            "name": "filter.allowDoubleLocks",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to return the total number of secrets matching the filters. False by default. If false, the total can be retrieved separately by calling   /api/v1/secrets/search-total with the same arguments used in the search.",
            "name": "filter.doNotCalculateTotal",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Only include Secrets with this DoubleLock ID assigned in the search results.",
            "name": "filter.doubleLockId",
            "in": "query"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi",
            "description": "An array of names of Secret Template fields to return.  Only exposed fields can be returned.",
            "name": "filter.extendedFields",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "If not null, return only secrets matching the specified extended mapping type as defined on the secret’s template.",
            "name": "filter.extendedTypeId",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "If not null, returns only secrets within the specified folder.",
            "name": "filter.folderId",
            "in": "query"
          },
          {
            "type": "string",
            "description": "If not null, returns only secrets with a certain heartbeat status.",
            "name": "filter.heartbeatStatus",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to include active secrets in results (when excluded equals true).",
            "name": "filter.includeActive",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to include inactive secrets in results.",
            "name": "filter.includeInactive",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to include restricted secrets in results. Restricted secrets are secrets that are DoubleLocked, require approval, or require a comment to view.",
            "name": "filter.includeRestricted",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to include secrets in subfolders of the specified folder.",
            "name": "filter.includeSubFolders",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to do an exact match of the search text or a partial match. If an exact match, the entire secret name, field value, or list option in a list field must match the search text.",
            "name": "filter.isExactMatch",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to only include secrets whose template has Remote Password Changing enabled.",
            "name": "filter.onlyRPCEnabled",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "When true only Secrets where you are not the owner and the Secret was shared explicitly with your user id will be returned.",
            "name": "filter.onlySharedWithMe",
            "in": "query"
          },
          {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "collectionFormat": "multi",
            "description": "If not null, returns only secrets matching the specified password types.",
            "name": "filter.passwordTypeIds",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Specify whether to filter by List, View, Edit, or Owner permission. Default is List.",
            "name": "filter.permissionRequired",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Specify whether to search All, Recent, or Favorites",
            "name": "filter.scope",
            "in": "query"
          },
          {
            "type": "string",
            "description": "If set, restricts the search to only match secrets where the value of the field specified by name contains the search text.",
            "name": "filter.searchField",
            "in": "query"
          },
          {
            "type": "string",
            "description": "If set, restricts the search to only match secrets where the value of the field specified by the slug name contains the search text. This will override SearchField.",
            "name": "filter.searchFieldSlug",
            "in": "query"
          },
          {
            "type": "string",
            "description": "The text to match in the secret name, field value, or list field contents.",
            "name": "filter.searchText",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "If not null, returns only secrets matching the specified template.",
            "name": "filter.secretTemplateId",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "If not null, returns only secrets within a the specified site.",
            "name": "filter.siteId",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Number of records to skip before taking results",
            "name": "skip",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort direction",
            "name": "sortBy[0].direction",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort field name",
            "name": "sortBy[0].name",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Priority index. Sorts with lower values are executed earlier",
            "name": "sortBy[0].priority",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Maximum number of records to include in results",
            "name": "take",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret search result object",
            "schema": {
              "$ref": "#/definitions/PagingOfSecretSummary"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      },
      "post": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Create a new secret",
        "tags": [
          "Secrets"
        ],
        "summary": "Create Secret",
        "operationId": "SecretsService_CreateSecret",
        "parameters": [
          {
            "description": "Secret creation options",
            "name": "secretCreateArgs",
            "in": "body",
            "schema": {
              "description": "Secret creation options",
              "$ref": "#/definitions/SecretCreateArgs"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Secret object",
            "schema": {
              "$ref": "#/definitions/SecretModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/extended-search-details": {
      "post": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Pass an array of secret IDs, presumably the results of a secret search and get extended details such as has launchers or is favorite.",
        "tags": [
          "Secrets"
        ],
        "summary": "Secret Search Extended Details",
        "operationId": "SecretsService_GetSecretExtendedSearchDetails",
        "parameters": [
          {
            "description": "args",
            "name": "args",
            "in": "body",
            "schema": {
              "description": "args",
              "$ref": "#/definitions/SecretSearchExtendedArgs"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Secret search extended details",
            "schema": {
              "description": "Secret search extended details",
              "type": "array",
              "items": {
                "$ref": "#/definitions/SecretSearchExtendedSummary"
              }
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/lookup": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Search, filter, sort, and page secrets, returning only secret ID and name",
        "tags": [
          "Secrets"
        ],
        "summary": "Lookup Secrets with Search",
        "operationId": "SecretsService_SearchSecretLookup",
        "parameters": [
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to allow DoubleLocks as part of the search. True by default.",
            "name": "filter.allowDoubleLocks",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to return the total number of secrets matching the filters. False by default. If false, the total can be retrieved separately by calling /v1/secrets/search-total with the same arguments used in the search.",
            "name": "filter.doNotCalculateTotal",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "Only include Secrets with this DoubleLock ID assigned in the search results.",
            "name": "filter.doubleLockId",
            "in": "query"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi",
            "description": "An array of names of Secret Template fields to return.  Only exposed fields can be returned.",
            "name": "filter.extendedFields",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "If not null, return only secrets matching the specified extended mapping type as defined on the secret’s template.",
            "name": "filter.extendedTypeId",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "If not null, returns only secrets within the specified folder.",
            "name": "filter.folderId",
            "in": "query"
          },
          {
            "type": "string",
            "x-nullable": true,
            "description": "If not null, returns only secrets with a certain heartbeat status.",
            "name": "filter.heartbeatStatus",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to include active secrets in results (when excluded equals true).",
            "name": "filter.includeActive",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to include inactive secrets in results.",
            "name": "filter.includeInactive",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to include restricted secrets in results. Restricted secrets are secrets that are DoubleLocked, require approval, or require a comment to view.",
            "name": "filter.includeRestricted",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to include secrets in subfolders of the specified folder.",
            "name": "filter.includeSubFolders",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to do an exact match of the search text or a partial match. If an exact match, the entire secret name, field value, or list option in a list field must match the search text.",
            "name": "filter.isExactMatch",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to only include secrets whose template has Remote Password Changing enabled.",
            "name": "filter.onlyRPCEnabled",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to only return secrets that are or are not checked out by the querying user. If null, returns secrets regardless of whether they are checked out.",
            "name": "filter.onlySecretsCheckedOutByUser",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "When true only Secrets where you are not the owner and the Secret was shared explicitly with your user id will be returned.",
            "name": "filter.onlySharedWithMe",
            "in": "query"
          },
          {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "collectionFormat": "multi",
            "description": "If not null, returns only secrets matching the specified password types.",
            "name": "filter.passwordTypeIds",
            "in": "query"
          },
          {
            "type": "string",
            "x-nullable": true,
            "description": "Specify whether to filter by List, View, Edit, or Owner permission. Default is List.",
            "name": "filter.permissionRequired",
            "in": "query"
          },
          {
            "type": "string",
            "x-nullable": true,
            "description": "Specify whether to search All, Recent, or Favorites",
            "name": "filter.scope",
            "in": "query"
          },
          {
            "type": "string",
            "description": "If set, restricts the search to only match secrets where the value of the field specified by name contains the search text.",
            "name": "filter.searchField",
            "in": "query"
          },
          {
            "type": "string",
            "description": "If set, restricts the search to only match secrets where the value of the field specified by the slug name contains the search text. This will override SearchField.",
            "name": "filter.searchFieldSlug",
            "in": "query"
          },
          {
            "type": "string",
            "description": "The text to match in the secret name, field value, or list field contents.",
            "name": "filter.searchText",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "If not null, returns only secrets matching the specified template.",
            "name": "filter.secretTemplateId",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "If not null, returns only secrets within a the specified site.",
            "name": "filter.siteId",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Number of records to skip before taking results",
            "name": "skip",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort direction",
            "name": "sortBy[0].direction",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort field name",
            "name": "sortBy[0].name",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Priority index. Sorts with lower values are executed earlier",
            "name": "sortBy[0].priority",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Maximum number of records to include in results",
            "name": "take",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret search result object",
            "schema": {
              "$ref": "#/definitions/PagingOfSecretLookup"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/lookup/{id}": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Look up secret by ID and return secret name and ID",
        "tags": [
          "Secrets"
        ],
        "summary": "Lookup Secret",
        "operationId": "SecretsService_GetLookup",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret lookup result object",
            "schema": {
              "$ref": "#/definitions/SecretLookup"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/secret-detail/{id}/general": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Retrieve details about a secret.",
        "tags": [
          "Secrets"
        ],
        "summary": "Get Secret Detail General",
        "operationId": "SecretsService_GetGeneral",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret Detail State View Model",
            "schema": {
              "description": "Secret Detail State View Model",
              "$ref": "#/definitions/SecretDetailGeneralModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/{id}": {
      "put": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Update a single secret by ID",
        "tags": [
          "Secrets"
        ],
        "summary": "Update Secret",
        "operationId": "SecretsService_UpdateSecret",
        "parameters": [
          {
            "description": "Secret update options",
            "name": "args",
            "in": "body",
            "schema": {
              "description": "Secret update options",
              "$ref": "#/definitions/SecretUpdateArgs"
            }
          },
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret object",
            "schema": {
              "$ref": "#/definitions/SecretModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      },
      "delete": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "A deactivated secret is hidden from users who do not have a role containing the View Inactive Secrets permission. Secret Server uses these \"soft deletes\" to maintain the audit history for all data. However, deactivated secrets are still accessible by administrators (like a permanent Recycle Bin) to ensure that audit history is maintained and to support recovery. A user must have the \"View Inactive Secrets\" permission in addition to Owner permission on a secret to access the secret View page for a deleted secret. To permanently remove all information on a secret, use the \"Erase Secret\" function.",
        "tags": [
          "Secrets"
        ],
        "summary": "Deactivate a Secret",
        "operationId": "SecretsService_Delete",
        "parameters": [
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Object deletion result",
            "schema": {
              "$ref": "#/definitions/DeletedModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/{id}/activate": {
      "put": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Undelete a Secret",
        "tags": [
          "Secrets"
        ],
        "summary": "Undelete a Secret",
        "operationId": "SecretsService_UndeleteSecret",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret",
            "schema": {
              "$ref": "#/definitions/SecretDetailGeneralModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/{id}/expiration": {
      "put": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Update a Secret expiration",
        "tags": [
          "Secrets"
        ],
        "summary": "Update a Secret expiration",
        "operationId": "SecretsService_UpdateExpiration",
        "parameters": [
          {
            "description": "args",
            "name": "args",
            "in": "body",
            "schema": {
              "description": "args",
              "$ref": "#/definitions/SecretDetailUpdateExpirationArgs"
            }
          },
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Updated secret settings",
            "schema": {
              "description": "Updated secret settings",
              "$ref": "#/definitions/SecretDetailSettingsModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/{id}/expire": {
      "post": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Expire a secret",
        "tags": [
          "Secrets"
        ],
        "summary": "Expire Secret",
        "operationId": "SecretsService_Expire",
        "parameters": [
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "description": "Secret options",
            "name": "restrictedArgs",
            "in": "body",
            "schema": {
              "description": "Secret options",
              "$ref": "#/definitions/SecretRestrictedArgs"
            }
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret summary object",
            "schema": {
              "$ref": "#/definitions/SecretSummary"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/{id}/fields/{slug}": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Get a secret data field",
        "produces": [
          "application/json",
          "application/octet-stream"
        ],
        "tags": [
          "Secrets"
        ],
        "summary": "Get Secret Field",
        "operationId": "SecretsService_GetField",
        "parameters": [
          {
            "type": "boolean",
            "description": "Whether to include inactive secrets in the results",
            "name": "includeInactive",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Don't check out the secret if needed",
            "name": "noAutoCheckout",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Secret field name",
            "name": "slug",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Secret field value. If the field is a file attachment, the content type will be ` + "`" + `application/octet-stream` + "`" + ` and the response body will be the file contents.",
            "schema": {
              "description": "String",
              "type": "string"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      },
      "put": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Update a secret data field",
        "consumes": [
          "application/json",
          "multipart/form-data"
        ],
        "tags": [
          "Secrets"
        ],
        "summary": "Update Secret Field",
        "operationId": "SecretsService_PutField",
        "parameters": [
          {
            "description": "Secret options",
            "name": "args",
            "in": "body",
            "schema": {
              "description": "Secret options",
              "$ref": "#/definitions/SecretItemUpdateArgs"
            }
          },
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Secret field name",
            "name": "slug",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "The updated value, or 'true' if the field is a file attachment",
            "schema": {
              "description": "String",
              "type": "string"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/{id}/fields/{slug}/list": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Get the items associated to a secret list data field",
        "tags": [
          "Secrets"
        ],
        "summary": "Get Secret List Field",
        "operationId": "SecretsService_GetListField",
        "parameters": [
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "Secret field name",
            "name": "slug",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Combined contents of all lists assigned to the secret field.",
            "schema": {
              "$ref": "#/definitions/CategorizedListItemValueResult"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/{id}/fields/{slug}/listdetails": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Get the lists associated to a secret list data field",
        "tags": [
          "Secrets"
        ],
        "summary": "Get Secret List Field List Data",
        "operationId": "SecretsService_GetListFieldListDefinitions",
        "parameters": [
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Number of records to skip before taking results",
            "name": "skip",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort direction",
            "name": "sortBy[0].direction",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort field name",
            "name": "sortBy[0].name",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Priority index. Sorts with lower values are executed earlier",
            "name": "sortBy[0].priority",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Maximum number of records to include in results",
            "name": "take",
            "in": "query"
          },
          {
            "type": "string",
            "description": "The field slug name of the list field. This is the fieldSlugName property of the SecretField object. By default, it is the lower-case field name with all spaces replaced with dashes (-).",
            "name": "slug",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Combined summary of all lists assigned to the secret field.",
            "schema": {
              "$ref": "#/definitions/PagingOfCategorizedListSummary"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      },
      "put": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Updates the lists associated to a secret list data field",
        "tags": [
          "Secrets"
        ],
        "summary": "Update Secret List Field List Data",
        "operationId": "SecretsService_UpdateListFieldListDefinitions",
        "parameters": [
          {
            "description": "Secret options",
            "name": "args",
            "in": "body",
            "schema": {
              "description": "Secret options",
              "$ref": "#/definitions/SecretListFieldListArgs"
            }
          },
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "Secret field name",
            "name": "slug",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Combined summary of all lists assigned to the secret field.",
            "schema": {
              "$ref": "#/definitions/PagingOfCategorizedListSummary"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      },
      "delete": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Deletes the lists associated to a secret list data field",
        "tags": [
          "Secrets"
        ],
        "summary": "Delete Secret List Field List Data",
        "operationId": "SecretsService_DeleteListFieldListDefinitions",
        "parameters": [
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "format": "uuid",
            "description": "Secret options",
            "name": "listGuid",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Secret field name",
            "name": "slug",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Combined summary of all lists assigned to the secret field.",
            "schema": {
              "$ref": "#/definitions/PagingOfCategorizedListSummary"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/{id}/heartbeat": {
      "post": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Check if secret is still valid",
        "tags": [
          "Secrets"
        ],
        "summary": "Run Secret Heartbeat",
        "operationId": "SecretsService_RunHeartBeat",
        "parameters": [
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret summary object",
            "schema": {
              "$ref": "#/definitions/SecretSummary"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/{id}/restricted": {
      "post": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Get a restricted secret",
        "tags": [
          "Secrets"
        ],
        "summary": "Get Restricted Secret",
        "operationId": "SecretsService_GetRestricted",
        "parameters": [
          {
            "description": "Secret options",
            "name": "args",
            "in": "body",
            "schema": {
              "description": "Secret options",
              "$ref": "#/definitions/SecretRestrictedArgs"
            }
          },
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret object",
            "schema": {
              "$ref": "#/definitions/SecretModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/secrets/{id}/state": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Retrieve state about a Secret such as whether it requires approval, doublelock, checkout, or other restricted actions to be performed before calling the get the secret.",
        "tags": [
          "Secrets"
        ],
        "summary": "Get Secret State",
        "operationId": "SecretsService_GetSecretState",
        "parameters": [
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret Detail State View Model",
            "schema": {
              "$ref": "#/definitions/SecretDetailStateViewModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/users/lookup": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Search, filter, sort, and page users, returning only user ID and name",
        "tags": [
          "Users"
        ],
        "summary": "Lookup Users",
        "operationId": "UsersService_Lookup",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "If not null, filters users by Active Directory domain.",
            "name": "filter.domainId",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "When set all subscribers not subscribed directly to this inbox notification rule will be excluded.",
            "name": "filter.excludeInboxRuleIdSubscribers",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to include inactive users in the results.",
            "name": "filter.includeInactive",
            "in": "query"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi",
            "description": "User fields to search.",
            "name": "filter.searchFields",
            "in": "query"
          },
          {
            "type": "string",
            "description": "The text to match in the username, display name, or email address.",
            "name": "filter.searchText",
            "in": "query"
          },
          {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "collectionFormat": "multi",
            "description": "User Ids to search.",
            "name": "filter.userIds",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Number of records to skip before taking results",
            "name": "skip",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort direction",
            "name": "sortBy[0].direction",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort field name",
            "name": "sortBy[0].name",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Priority index. Sorts with lower values are executed earlier",
            "name": "sortBy[0].priority",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Maximum number of records to include in results",
            "name": "take",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "User search result object",
            "schema": {
              "$ref": "#/definitions/PagingOfUserLookup"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/users/{id}": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Get a single user by ID",
        "tags": [
          "Users"
        ],
        "summary": "Get User",
        "operationId": "UsersService_Get",
        "parameters": [
          {
            "type": "boolean",
            "description": "Whether to include inactive users in the results",
            "name": "includeInactive",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "User ID",
            "name": "id",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "User object",
            "schema": {
              "$ref": "#/definitions/UserModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      },
      "put": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Update a single user by ID",
        "tags": [
          "Users"
        ],
        "summary": "Update User",
        "operationId": "UsersService_UpdateUser",
        "parameters": [
          {
            "description": "User update options",
            "name": "args",
            "in": "body",
            "schema": {
              "description": "User update options",
              "$ref": "#/definitions/UserUpdateArgs"
            }
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "User ID",
            "name": "id",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "User object",
            "schema": {
              "$ref": "#/definitions/UserModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      },
      "patch": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Update included properties for user by Id",
        "tags": [
          "Users"
        ],
        "summary": "Update included properties for user by Id",
        "operationId": "UsersService_PatchUser",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "description": "patchModel",
            "name": "patchModel",
            "in": "body",
            "schema": {
              "description": "patchModel",
              "$ref": "#/definitions/PatchUserModel"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "User Configuration",
            "schema": {
              "$ref": "#/definitions/UserModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/users/{id}/roles": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Gets roles for user",
        "tags": [
          "Users"
        ],
        "summary": "Gets roles for user",
        "operationId": "UsersService_GetRoles",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "description": "Number of records to skip before taking results",
            "name": "skip",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort direction",
            "name": "sortBy[0].direction",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort field name",
            "name": "sortBy[0].name",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Priority index. Sorts with lower values are executed earlier",
            "name": "sortBy[0].priority",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Maximum number of records to include in results",
            "name": "take",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success / Fail",
            "schema": {
              "$ref": "#/definitions/PagingOfRoleSummary"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      },
      "put": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Update all roles on user",
        "tags": [
          "Users"
        ],
        "summary": "Update all roles on user",
        "operationId": "UsersService_UpdateUserRoles",
        "parameters": [
          {
            "description": "args",
            "name": "args",
            "in": "body",
            "schema": {
              "description": "args",
              "$ref": "#/definitions/RoleAssignments"
            }
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success / Fail",
            "schema": {
              "$ref": "#/definitions/RoleChangeStatusModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      },
      "post": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Add roles to existing user",
        "tags": [
          "Users"
        ],
        "summary": "Add roles to existing user",
        "operationId": "UsersService_CreateUserRoles",
        "parameters": [
          {
            "description": "args",
            "name": "args",
            "in": "body",
            "schema": {
              "description": "args",
              "$ref": "#/definitions/RoleAssignments"
            }
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success / Fail",
            "schema": {
              "$ref": "#/definitions/RoleChangeStatusModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v1/users/{userId}/roles-assigned": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Get the roles for a user by ID",
        "tags": [
          "Users"
        ],
        "summary": "Get User Roles",
        "operationId": "UsersService_GetUserRoles",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "description": "Number of records to skip before taking results",
            "name": "skip",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort direction",
            "name": "sortBy[0].direction",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort field name",
            "name": "sortBy[0].name",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Priority index. Sorts with lower values are executed earlier",
            "name": "sortBy[0].priority",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Maximum number of records to include in results",
            "name": "take",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "User ID",
            "name": "userId",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "User role summary",
            "schema": {
              "$ref": "#/definitions/PagingOfUserRoleSummary"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v2/secrets": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Search, filter, sort, and page secrets",
        "tags": [
          "Secrets"
        ],
        "summary": "Search Secrets",
        "operationId": "SecretsService_SearchV2",
        "parameters": [
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to allow DoubleLocks as part of the search. True by default.",
            "name": "filter.allowDoubleLocks",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to return the total number of secrets matching the filters. False by default. If false, the total can be retrieved separately by calling /v1/secrets/search-total with the same arguments used in the search.",
            "name": "filter.doNotCalculateTotal",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "Only include Secrets with this DoubleLock ID assigned in the search results.",
            "name": "filter.doubleLockId",
            "in": "query"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi",
            "description": "An array of names of Secret Template fields to return.  Only exposed fields can be returned.  This parameter will be ignored if ExtFieldsCombined is sent.",
            "name": "filter.extendedFields",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "If not null, return only secrets matching the specified extended mapping type as defined on the secret’s template.",
            "name": "filter.extendedTypeId",
            "in": "query"
          },
          {
            "type": "string",
            "description": "A comma delimited list of all extended fields to return.  All fields must be marked as exposed for display.  When populated this value will be used instead of ExtendedFields[].  Combining the fields decreases the size of the GET URL to avoid the 2048 character length restriction in IIS.",
            "name": "filter.extFieldsCombined",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "If not null, returns only secrets within the specified folder.",
            "name": "filter.folderId",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to only return secrets with or without launchers. If null, returns secrets regardless of whether they have launchers.",
            "name": "filter.hasLauncher",
            "in": "query"
          },
          {
            "type": "string",
            "x-nullable": true,
            "description": "If not null, returns only secrets with a certain heartbeat status.",
            "name": "filter.heartbeatStatus",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to include active secrets in results (when excluded equals true).",
            "name": "filter.includeActive",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to include inactive secrets in results.",
            "name": "filter.includeInactive",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to include restricted secrets in results. Restricted secrets are secrets that are DoubleLocked, require approval, or require a comment to view.",
            "name": "filter.includeRestricted",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Whether to include secrets in subfolders of the specified folder.",
            "name": "filter.includeSubFolders",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to do an exact match of the search text or a partial match. If an exact match, the entire secret name, field value, or list option in a list field must match the search text.",
            "name": "filter.isExactMatch",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to only return secrets that are or are not checked out. If null, returns secrets regardless of whether they are checked out.",
            "name": "filter.onlyCheckedOutSecrets",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to only include secrets whose template has Remote Password Changing enabled.",
            "name": "filter.onlyRPCEnabled",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "Whether to only return secrets that are or are not checked out by the querying user. If null, returns secrets regardless of whether they are checked out.",
            "name": "filter.onlySecretsCheckedOutByUser",
            "in": "query"
          },
          {
            "type": "boolean",
            "x-nullable": true,
            "description": "When true only Secrets where you are not the owner and the Secret was shared explicitly with your user id will be returned.",
            "name": "filter.onlySharedWithMe",
            "in": "query"
          },
          {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "collectionFormat": "multi",
            "description": "If not null, returns only secrets matching the specified password types.",
            "name": "filter.passwordTypeIds",
            "in": "query"
          },
          {
            "type": "string",
            "x-nullable": true,
            "description": "Specify whether to filter by List, View, Edit, or Owner permission. Default is List.",
            "name": "filter.permissionRequired",
            "in": "query"
          },
          {
            "type": "string",
            "x-nullable": true,
            "description": "Specify whether to search All, Recent, or Favorites",
            "name": "filter.scope",
            "in": "query"
          },
          {
            "type": "string",
            "description": "If set, restricts the search to only match secrets where the value of the field specified by name contains the search text.",
            "name": "filter.searchField",
            "in": "query"
          },
          {
            "type": "string",
            "description": "If set, restricts the search to only match secrets where the value of the field specified by the slug name contains the search text. This will override SearchField.",
            "name": "filter.searchFieldSlug",
            "in": "query"
          },
          {
            "type": "string",
            "description": "The text to match in the secret name, field value, or list field contents.",
            "name": "filter.searchText",
            "in": "query"
          },
          {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "collectionFormat": "multi",
            "description": "If not null or empty, returns only secrets matching the specified secret ids.",
            "name": "filter.secretIds",
            "in": "query"
          },
          {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "collectionFormat": "multi",
            "description": "If not null or empty, returns only secrets matching the specified templates.",
            "name": "filter.secretTemplateIds",
            "in": "query"
          },
          {
            "type": "string",
            "description": "A comma delimited list of all secret template IDs.  When populated this value will be used instead of SecretTemplateIds[].  Combining the fields decreases the size of the GET URL to avoid the 2048 character length restriction in IIS.",
            "name": "filter.secretTemplateIdsCombined",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "x-nullable": true,
            "description": "If not null, returns only secrets within a the specified site.",
            "name": "filter.siteId",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Number of records to skip before taking results",
            "name": "skip",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort direction",
            "name": "sortBy[0].direction",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Sort field name",
            "name": "sortBy[0].name",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Priority index. Sorts with lower values are executed earlier",
            "name": "sortBy[0].priority",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Maximum number of records to include in results",
            "name": "take",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret search result object",
            "schema": {
              "$ref": "#/definitions/PagingOfSecretSummary"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v2/secrets/{id}": {
      "get": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Get a single secret by ID",
        "tags": [
          "Secrets"
        ],
        "summary": "Get Secret",
        "operationId": "SecretsService_GetSecretV2",
        "parameters": [
          {
            "type": "boolean",
            "description": "Whether to include inactive secrets in the results",
            "name": "includeInactive",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Don't check out the secret if needed",
            "name": "noAutoCheckout",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check in a secret after finding or updating.",
            "name": "autoCheckIn",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Automatically check out secret before finding or updating.",
            "name": "autoCheckout",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Leave a comment when checking in or out.",
            "name": "autoComment",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "If secret is checked out, then force a check in.",
            "name": "forceCheckIn",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "int32",
            "description": "Secret ID",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret object",
            "schema": {
              "$ref": "#/definitions/SecretModelV2"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/api/v2/secrets/{id}/activate": {
      "put": {
        "security": [
          {
            "Bearer": []
          }
        ],
        "description": "Undelete a Secret",
        "tags": [
          "Secrets"
        ],
        "summary": "Undelete a Secret",
        "operationId": "SecretsService_UndeleteSecretV2",
        "parameters": [
          {
            "type": "integer",
            "format": "int32",
            "description": "id",
            "name": "id",
            "in": "path",
            "required": true
          },
          {
            "type": "string",
            "description": "A full path including folder and secret name can be passed as a query string parameter when the secret ID is set to 0.  This will lookup the secret ID by path.",
            "name": "secretPath",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Secret",
            "schema": {
              "$ref": "#/definitions/SecretDetailGeneralModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/BadRequestResponse"
            }
          },
          "403": {
            "description": "Authentication failed",
            "schema": {
              "$ref": "#/definitions/AuthenticationFailedResponse"
            }
          },
          "500": {
            "description": "Internal server error",
            "schema": {
              "$ref": "#/definitions/InternalServerErrorResponse"
            }
          }
        }
      }
    },
    "/oauth2/token": {
      "post": {
        "description": "Retrieve an access token for use with other API requests or refresh an access token.",
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "tags": [
          "Authentication"
        ],
        "summary": "Retrieve or Refresh Access Token",
        "operationId": "OAuth2Service_Authorize",
        "parameters": [
          {
            "enum": [
              "password",
              "refresh_token"
            ],
            "type": "string",
            "description": "Authentication grant type.  Use 'password' when authenticating, and 'refresh_token' when refreshing a token.",
            "name": "grant_type",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "Secret Server authentication username.  Required when authenticating.",
            "name": "username",
            "in": "formData"
          },
          {
            "type": "string",
            "description": "Secret Server authentication password.  Required when authenticating.",
            "name": "password",
            "in": "formData"
          },
          {
            "type": "string",
            "description": "The refresh token.  Required when refreshing a token.",
            "name": "refresh_token",
            "in": "formData"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful retrieval of an access token",
            "schema": {
              "$ref": "#/definitions/TokenResponse"
            }
          },
          "400": {
            "description": "An error occurred",
            "schema": {
              "$ref": "#/definitions/TokenErrorResponse"
            }
          }
        }
      }
    }
  },
  "definitions": {
    "AuthenticationFailedResponse": {
      "description": "Response object for authentication failures",
      "type": "object",
      "required": [
        "message"
      ],
      "properties": {
        "message": {
          "description": "Error message",
          "type": "string"
        }
      }
    },
    "BadRequestResponse": {
      "description": "Response object for invalid requests",
      "type": "object",
      "required": [
        "message"
      ],
      "properties": {
        "errorCode": {
          "description": "Error message code",
          "type": "string"
        },
        "message": {
          "description": "Error message",
          "type": "string"
        },
        "messageDetail": {
          "description": "Error message detail",
          "type": "string"
        },
        "modelState": {
          "description": "An object describing validation errors",
          "type": "object"
        }
      }
    },
    "CategorizedListItemValueResult": {
      "description": "CategorizedListItemValueResult",
      "type": "object",
      "properties": {
        "value": {
          "description": "Value",
          "type": "array",
          "items": {
            "$ref": "#/definitions/ICategorizedListItemValue"
          }
        }
      }
    },
    "CategorizedListSummary": {
      "description": "Query results",
      "type": "object",
      "properties": {
        "active": {
          "description": "Whether or not the list is active",
          "type": "boolean"
        },
        "categorizedListId": {
          "description": "List Id",
          "type": "string"
        },
        "description": {
          "description": "Description of the list",
          "type": "string"
        },
        "name": {
          "description": "Name of the list",
          "type": "string"
        },
        "numOptions": {
          "description": "The number of options in the list",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "DeletedModel": {
      "description": "Information about an object that was deleted",
      "type": "object",
      "properties": {
        "id": {
          "description": "ID of the deleted object",
          "type": "integer",
          "format": "int32"
        },
        "objectType": {
          "description": "Type of the deleted object",
          "type": "string"
        },
        "responseCodes": {
          "description": "List of response codes from the delete operation",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "GroupAssignedRoleModel": {
      "description": "All of the groups to which the user belongs that have this role",
      "type": "object",
      "properties": {
        "groupId": {
          "description": "GroupId",
          "type": "integer",
          "format": "int32"
        },
        "groupName": {
          "description": "GroupName",
          "type": "string"
        }
      }
    },
    "GroupMembershipFilter": {
      "description": "Group membership filter",
      "type": "object",
      "properties": {
        "includeInactiveUsersForGroup": {
          "description": "Whether to include inactive users in the results",
          "type": "boolean"
        },
        "userDomainId": {
          "description": "Filter only users in a specific domain",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        }
      }
    },
    "HeartbeatStatus": {
      "description": "Current status of heartbeat",
      "type": "string",
      "enum": [
        "Failed",
        "Success",
        "Pending",
        "Disabled",
        "UnableToConnect",
        "UnknownError",
        "IncompatibleHost",
        "AccountLockedOut",
        "DnsMismatch",
        "UnableToValidateServerPublicKey",
        "Processing",
        "ArgumentError",
        "AccessDenied"
      ]
    },
    "ICategorizedListItemValue": {
      "description": "The restricted hosts.",
      "type": "object",
      "properties": {
        "category": {
          "description": "Category",
          "type": "string"
        },
        "value": {
          "description": "Value",
          "type": "string"
        }
      }
    },
    "ISecretSummaryExtendedField": {
      "description": "Any requested extended fields from a lookup request",
      "type": "object",
      "properties": {
        "name": {
          "description": "Name",
          "type": "string"
        },
        "value": {
          "description": "Value",
          "type": "string"
        }
      }
    },
    "InternalServerErrorResponse": {
      "description": "Response object for internal server errors",
      "type": "object",
      "required": [
        "message",
        "exceptionMessage",
        "exceptionType",
        "stackTrace"
      ],
      "properties": {
        "exceptionMessage": {
          "description": "Error message from exception",
          "type": "string"
        },
        "exceptionType": {
          "description": "Exception type",
          "type": "string"
        },
        "message": {
          "description": "Error message",
          "type": "string"
        },
        "stackTrace": {
          "description": "Exception stack trace",
          "type": "string"
        }
      }
    },
    "PagingOfCategorizedListSummary": {
      "description": "Specify paging and sorting options for querying records and returning results",
      "type": "object",
      "properties": {
        "batchCount": {
          "description": "Number of result batches available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "currentPage": {
          "description": "Index of current result page",
          "type": "integer",
          "format": "int32"
        },
        "hasNext": {
          "description": "Whether there are any results in additional pages",
          "type": "boolean"
        },
        "hasPrev": {
          "description": "Whether there are any results in previous pages",
          "type": "boolean"
        },
        "nextSkip": {
          "description": "Correct value of 'skip' for the next page of results",
          "type": "integer",
          "format": "int32"
        },
        "pageCount": {
          "description": "Number of result pages available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "prevSkip": {
          "description": "Correct value of 'skip' for the previous page of results",
          "type": "integer",
          "format": "int32"
        },
        "records": {
          "description": "Query results",
          "type": "array",
          "items": {
            "$ref": "#/definitions/CategorizedListSummary"
          }
        },
        "severity": {
          "description": "Severity of any errors",
          "$ref": "#/definitions/Severity"
        },
        "skip": {
          "description": "Number of records to skip before taking results",
          "type": "integer",
          "format": "int32"
        },
        "sortBy": {
          "description": "List of sort properties",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Sort"
          }
        },
        "success": {
          "description": "Whether the query executed successfully",
          "type": "boolean"
        },
        "take": {
          "description": "Maximum number of records to include in results",
          "type": "integer",
          "format": "int32"
        },
        "total": {
          "description": "Total number of results available",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "PagingOfRoleGroupSummaryAndGroupMembershipFilter": {
      "description": "Specify filtering, paging, sorting options for querying records and returning results",
      "type": "object",
      "properties": {
        "batchCount": {
          "description": "Number of result batches available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "currentPage": {
          "description": "Index of current result page",
          "type": "integer",
          "format": "int32"
        },
        "filter": {
          "description": "Additional query options",
          "$ref": "#/definitions/GroupMembershipFilter"
        },
        "hasNext": {
          "description": "Whether there are any results in additional pages",
          "type": "boolean"
        },
        "hasPrev": {
          "description": "Whether there are any results in previous pages",
          "type": "boolean"
        },
        "nextSkip": {
          "description": "Correct value of 'skip' for the next page of results",
          "type": "integer",
          "format": "int32"
        },
        "pageCount": {
          "description": "Number of result pages available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "prevSkip": {
          "description": "Correct value of 'skip' for the previous page of results",
          "type": "integer",
          "format": "int32"
        },
        "records": {
          "description": "Query results",
          "type": "array",
          "items": {
            "$ref": "#/definitions/RoleGroupSummary"
          }
        },
        "severity": {
          "description": "Severity of any errors",
          "$ref": "#/definitions/Severity"
        },
        "skip": {
          "description": "Number of records to skip before taking results",
          "type": "integer",
          "format": "int32"
        },
        "sortBy": {
          "description": "List of sort properties",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Sort"
          }
        },
        "success": {
          "description": "Whether the query executed successfully",
          "type": "boolean"
        },
        "take": {
          "description": "Maximum number of records to include in results",
          "type": "integer",
          "format": "int32"
        },
        "total": {
          "description": "Total number of results available",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "PagingOfRoleModel": {
      "description": "Specify paging and sorting options for querying records and returning results",
      "type": "object",
      "properties": {
        "batchCount": {
          "description": "Number of result batches available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "currentPage": {
          "description": "Index of current result page",
          "type": "integer",
          "format": "int32"
        },
        "hasNext": {
          "description": "Whether there are any results in additional pages",
          "type": "boolean"
        },
        "hasPrev": {
          "description": "Whether there are any results in previous pages",
          "type": "boolean"
        },
        "nextSkip": {
          "description": "Correct value of 'skip' for the next page of results",
          "type": "integer",
          "format": "int32"
        },
        "pageCount": {
          "description": "Number of result pages available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "prevSkip": {
          "description": "Correct value of 'skip' for the previous page of results",
          "type": "integer",
          "format": "int32"
        },
        "records": {
          "description": "Query results",
          "type": "array",
          "items": {
            "$ref": "#/definitions/RoleModel"
          }
        },
        "severity": {
          "description": "Severity of any errors",
          "$ref": "#/definitions/Severity"
        },
        "skip": {
          "description": "Number of records to skip before taking results",
          "type": "integer",
          "format": "int32"
        },
        "sortBy": {
          "description": "List of sort properties",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Sort"
          }
        },
        "success": {
          "description": "Whether the query executed successfully",
          "type": "boolean"
        },
        "take": {
          "description": "Maximum number of records to include in results",
          "type": "integer",
          "format": "int32"
        },
        "total": {
          "description": "Total number of results available",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "PagingOfRolePermissionModel": {
      "description": "Specify paging and sorting options for querying records and returning results",
      "type": "object",
      "properties": {
        "batchCount": {
          "description": "Number of result batches available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "currentPage": {
          "description": "Index of current result page",
          "type": "integer",
          "format": "int32"
        },
        "hasNext": {
          "description": "Whether there are any results in additional pages",
          "type": "boolean"
        },
        "hasPrev": {
          "description": "Whether there are any results in previous pages",
          "type": "boolean"
        },
        "nextSkip": {
          "description": "Correct value of 'skip' for the next page of results",
          "type": "integer",
          "format": "int32"
        },
        "pageCount": {
          "description": "Number of result pages available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "prevSkip": {
          "description": "Correct value of 'skip' for the previous page of results",
          "type": "integer",
          "format": "int32"
        },
        "records": {
          "description": "Query results",
          "type": "array",
          "items": {
            "$ref": "#/definitions/RolePermissionModel"
          }
        },
        "severity": {
          "description": "Severity of any errors",
          "$ref": "#/definitions/Severity"
        },
        "skip": {
          "description": "Number of records to skip before taking results",
          "type": "integer",
          "format": "int32"
        },
        "sortBy": {
          "description": "List of sort properties",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Sort"
          }
        },
        "success": {
          "description": "Whether the query executed successfully",
          "type": "boolean"
        },
        "take": {
          "description": "Maximum number of records to include in results",
          "type": "integer",
          "format": "int32"
        },
        "total": {
          "description": "Total number of results available",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "PagingOfRoleSummary": {
      "description": "Specify paging and sorting options for querying records and returning results",
      "type": "object",
      "properties": {
        "batchCount": {
          "description": "Number of result batches available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "currentPage": {
          "description": "Index of current result page",
          "type": "integer",
          "format": "int32"
        },
        "hasNext": {
          "description": "Whether there are any results in additional pages",
          "type": "boolean"
        },
        "hasPrev": {
          "description": "Whether there are any results in previous pages",
          "type": "boolean"
        },
        "nextSkip": {
          "description": "Correct value of 'skip' for the next page of results",
          "type": "integer",
          "format": "int32"
        },
        "pageCount": {
          "description": "Number of result pages available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "prevSkip": {
          "description": "Correct value of 'skip' for the previous page of results",
          "type": "integer",
          "format": "int32"
        },
        "records": {
          "description": "Query results",
          "type": "array",
          "items": {
            "$ref": "#/definitions/RoleSummary"
          }
        },
        "severity": {
          "description": "Severity of any errors",
          "$ref": "#/definitions/Severity"
        },
        "skip": {
          "description": "Number of records to skip before taking results",
          "type": "integer",
          "format": "int32"
        },
        "sortBy": {
          "description": "List of sort properties",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Sort"
          }
        },
        "success": {
          "description": "Whether the query executed successfully",
          "type": "boolean"
        },
        "take": {
          "description": "Maximum number of records to include in results",
          "type": "integer",
          "format": "int32"
        },
        "total": {
          "description": "Total number of results available",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "PagingOfSecretLookup": {
      "description": "Specify paging and sorting options for querying records and returning results",
      "type": "object",
      "properties": {
        "batchCount": {
          "description": "Number of result batches available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "currentPage": {
          "description": "Index of current result page",
          "type": "integer",
          "format": "int32"
        },
        "hasNext": {
          "description": "Whether there are any results in additional pages",
          "type": "boolean"
        },
        "hasPrev": {
          "description": "Whether there are any results in previous pages",
          "type": "boolean"
        },
        "nextSkip": {
          "description": "Correct value of 'skip' for the next page of results",
          "type": "integer",
          "format": "int32"
        },
        "pageCount": {
          "description": "Number of result pages available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "prevSkip": {
          "description": "Correct value of 'skip' for the previous page of results",
          "type": "integer",
          "format": "int32"
        },
        "records": {
          "description": "Query results",
          "type": "array",
          "items": {
            "$ref": "#/definitions/SecretLookup"
          }
        },
        "severity": {
          "description": "Severity of any errors",
          "$ref": "#/definitions/Severity"
        },
        "skip": {
          "description": "Number of records to skip before taking results",
          "type": "integer",
          "format": "int32"
        },
        "sortBy": {
          "description": "List of sort properties",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Sort"
          }
        },
        "success": {
          "description": "Whether the query executed successfully",
          "type": "boolean"
        },
        "take": {
          "description": "Maximum number of records to include in results",
          "type": "integer",
          "format": "int32"
        },
        "total": {
          "description": "Total number of results available",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "PagingOfSecretSummary": {
      "description": "Specify paging and sorting options for querying records and returning results",
      "type": "object",
      "properties": {
        "batchCount": {
          "description": "Number of result batches available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "currentPage": {
          "description": "Index of current result page",
          "type": "integer",
          "format": "int32"
        },
        "hasNext": {
          "description": "Whether there are any results in additional pages",
          "type": "boolean"
        },
        "hasPrev": {
          "description": "Whether there are any results in previous pages",
          "type": "boolean"
        },
        "nextSkip": {
          "description": "Correct value of 'skip' for the next page of results",
          "type": "integer",
          "format": "int32"
        },
        "pageCount": {
          "description": "Number of result pages available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "prevSkip": {
          "description": "Correct value of 'skip' for the previous page of results",
          "type": "integer",
          "format": "int32"
        },
        "records": {
          "description": "Query results",
          "type": "array",
          "items": {
            "$ref": "#/definitions/SecretSummary"
          }
        },
        "severity": {
          "description": "Severity of any errors",
          "$ref": "#/definitions/Severity"
        },
        "skip": {
          "description": "Number of records to skip before taking results",
          "type": "integer",
          "format": "int32"
        },
        "sortBy": {
          "description": "List of sort properties",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Sort"
          }
        },
        "success": {
          "description": "Whether the query executed successfully",
          "type": "boolean"
        },
        "take": {
          "description": "Maximum number of records to include in results",
          "type": "integer",
          "format": "int32"
        },
        "total": {
          "description": "Total number of results available",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "PagingOfUserLookup": {
      "description": "Specify paging and sorting options for querying records and returning results",
      "type": "object",
      "properties": {
        "batchCount": {
          "description": "Number of result batches available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "currentPage": {
          "description": "Index of current result page",
          "type": "integer",
          "format": "int32"
        },
        "hasNext": {
          "description": "Whether there are any results in additional pages",
          "type": "boolean"
        },
        "hasPrev": {
          "description": "Whether there are any results in previous pages",
          "type": "boolean"
        },
        "nextSkip": {
          "description": "Correct value of 'skip' for the next page of results",
          "type": "integer",
          "format": "int32"
        },
        "pageCount": {
          "description": "Number of result pages available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "prevSkip": {
          "description": "Correct value of 'skip' for the previous page of results",
          "type": "integer",
          "format": "int32"
        },
        "records": {
          "description": "Query results",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UserLookup"
          }
        },
        "severity": {
          "description": "Severity of any errors",
          "$ref": "#/definitions/Severity"
        },
        "skip": {
          "description": "Number of records to skip before taking results",
          "type": "integer",
          "format": "int32"
        },
        "sortBy": {
          "description": "List of sort properties",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Sort"
          }
        },
        "success": {
          "description": "Whether the query executed successfully",
          "type": "boolean"
        },
        "take": {
          "description": "Maximum number of records to include in results",
          "type": "integer",
          "format": "int32"
        },
        "total": {
          "description": "Total number of results available",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "PagingOfUserRoleSummary": {
      "description": "Specify paging and sorting options for querying records and returning results",
      "type": "object",
      "properties": {
        "batchCount": {
          "description": "Number of result batches available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "currentPage": {
          "description": "Index of current result page",
          "type": "integer",
          "format": "int32"
        },
        "hasNext": {
          "description": "Whether there are any results in additional pages",
          "type": "boolean"
        },
        "hasPrev": {
          "description": "Whether there are any results in previous pages",
          "type": "boolean"
        },
        "nextSkip": {
          "description": "Correct value of 'skip' for the next page of results",
          "type": "integer",
          "format": "int32"
        },
        "pageCount": {
          "description": "Number of result pages available with current query options",
          "type": "integer",
          "format": "int32"
        },
        "prevSkip": {
          "description": "Correct value of 'skip' for the previous page of results",
          "type": "integer",
          "format": "int32"
        },
        "records": {
          "description": "Query results",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UserRoleSummary"
          }
        },
        "severity": {
          "description": "Severity of any errors",
          "$ref": "#/definitions/Severity"
        },
        "skip": {
          "description": "Number of records to skip before taking results",
          "type": "integer",
          "format": "int32"
        },
        "sortBy": {
          "description": "List of sort properties",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Sort"
          }
        },
        "success": {
          "description": "Whether the query executed successfully",
          "type": "boolean"
        },
        "take": {
          "description": "Maximum number of records to include in results",
          "type": "integer",
          "format": "int32"
        },
        "total": {
          "description": "Total number of results available",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "PatchUserModel": {
      "description": "PatchUserModel",
      "type": "object",
      "properties": {
        "dateOptionId": {
          "description": "DateOptionId",
          "$ref": "#/definitions/UpdateFieldValueOfInt32"
        },
        "displayName": {
          "description": "Display name",
          "$ref": "#/definitions/UpdateFieldValueOfString"
        },
        "duoTwoFactor": {
          "description": "Whether Duo two-factor authentication is enabled",
          "$ref": "#/definitions/UpdateFieldValueOfBoolean"
        },
        "emailAddress": {
          "description": "Email address",
          "$ref": "#/definitions/UpdateFieldValueOfString"
        },
        "enabled": {
          "description": "Whether the user account is enabled",
          "$ref": "#/definitions/UpdateFieldValueOfBoolean"
        },
        "fido2TwoFactor": {
          "description": "Whether FIDO2 two-factor authentication is enabled",
          "$ref": "#/definitions/UpdateFieldValueOfBoolean"
        },
        "groupOwners": {
          "description": "GroupOwners",
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        },
        "id": {
          "description": "User ID. Must match ID in path",
          "type": "integer",
          "format": "int32"
        },
        "ipAddressRestrictionIds": {
          "description": "List of IP Address Restriction Ids for the user. This will completely replace whatever restrictions existed previously.",
          "$ref": "#/definitions/UpdateFieldValueOfInt32"
        },
        "isApplicationAccount": {
          "description": "IsApplicationAccount",
          "$ref": "#/definitions/UpdateFieldValueOfBoolean"
        },
        "isGroupOwnerUpdate": {
          "description": "IsGroupOwnerUpdate",
          "type": "boolean"
        },
        "isLockedOut": {
          "description": "Whether the user is locked out",
          "$ref": "#/definitions/UpdateFieldValueOfBoolean"
        },
        "loginFailures": {
          "description": "Number of login failures",
          "$ref": "#/definitions/UpdateFieldValueOfInt32"
        },
        "oathTwoFactor": {
          "description": "Whether OATH two-factor authentication is enabled",
          "$ref": "#/definitions/UpdateFieldValueOfBoolean"
        },
        "password": {
          "description": "Password",
          "$ref": "#/definitions/UpdateFieldValueOfString"
        },
        "radiusTwoFactor": {
          "description": "Whether RADIUS two-factor authentication is enabled",
          "$ref": "#/definitions/UpdateFieldValueOfBoolean"
        },
        "radiusUserName": {
          "description": "RADIUS username",
          "$ref": "#/definitions/UpdateFieldValueOfString"
        },
        "slackId": {
          "description": "Slack ID",
          "$ref": "#/definitions/UpdateFieldValueOfString"
        },
        "timeOptionId": {
          "description": "TimeOptionId",
          "$ref": "#/definitions/UpdateFieldValueOfInt32"
        },
        "twoFactor": {
          "description": "Whether two-factor authentication is enabled",
          "$ref": "#/definitions/UpdateFieldValueOfBoolean"
        }
      }
    },
    "RestSecretItem": {
      "description": "Secret data field item",
      "type": "object",
      "properties": {
        "fieldDescription": {
          "description": "Longer description of the secret field.",
          "type": "string"
        },
        "fieldId": {
          "description": "The id of the field definition from the secret template.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "fieldName": {
          "description": "The display name of the secret field.",
          "type": "string"
        },
        "fileAttachmentId": {
          "description": "If the field is a file attachment field, the id of the file attachment.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "filename": {
          "description": "If the field is a file attachment field, the name of the attached file.",
          "type": "string"
        },
        "isFile": {
          "description": "Whether the field is a file attachment.",
          "type": "boolean"
        },
        "isList": {
          "description": "Whether or not the secret field is a list.",
          "type": "boolean"
        },
        "isNotes": {
          "description": "Whether the field is represented as a multi-line text box. Used for long-form text fields.",
          "type": "boolean"
        },
        "isPassword": {
          "description": "Whether the field is a password. Password fields are hidden by default in the UI and their value is not returned in GET calls that return secrets. To retrieve a password field value, make a GET call to /api/secrets/{secretId}/fields/{slug}.",
          "type": "boolean"
        },
        "itemId": {
          "description": "The id of the secret field item. Leave empty when creating a new secret.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "itemValue": {
          "description": "The value of the secret field item. For list fields, this is a comma-delimited list of the list id guids that are assigned to this field.",
          "type": "string"
        },
        "listType": {
          "description": "The type of list. Valid values are “None”, “Generic”, and “URL”.",
          "$ref": "#/definitions/SecretFieldListType"
        },
        "slug": {
          "description": "A unique name for the secret field on the template. Slugs cannot contain spaces and are used in many places to easily refer to a secret field without having to know the field id.",
          "type": "string"
        }
      }
    },
    "RoleAssignments": {
      "description": "Roles to be assigned",
      "type": "object",
      "properties": {
        "roleIds": {
          "description": "Role IDs",
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        }
      }
    },
    "RoleChangeStatusModel": {
      "description": "The status of the Role change action.",
      "type": "object",
      "properties": {
        "success": {
          "description": "The success or failure of the user or group role action.",
          "type": "boolean"
        }
      }
    },
    "RoleCreateArgs": {
      "description": "Role create options",
      "type": "object",
      "required": [
        "name",
        "enabled"
      ],
      "properties": {
        "enabled": {
          "description": "Whether the Role is active",
          "type": "boolean"
        },
        "name": {
          "description": "Role name",
          "type": "string"
        }
      }
    },
    "RoleGroupSummary": {
      "description": "Group",
      "type": "object",
      "properties": {
        "created": {
          "description": "Created Date",
          "type": "string",
          "format": "date-time"
        },
        "displayName": {
          "description": "Group display name",
          "type": "string"
        },
        "domainName": {
          "description": "Active Directory domain name",
          "type": "string"
        },
        "enabled": {
          "description": "Whether the group is active",
          "type": "boolean"
        },
        "groupId": {
          "description": "Group ID",
          "type": "integer",
          "format": "int32"
        },
        "name": {
          "description": "Group name",
          "type": "string"
        },
        "personal": {
          "description": "Whether the group is for a single user",
          "type": "boolean"
        }
      }
    },
    "RoleGroupsPatchArgs": {
      "description": "RoleGroupsPatchArgs",
      "type": "object",
      "properties": {
        "data": {
          "description": "Data",
          "$ref": "#/definitions/RoleGroupsPatchModel"
        }
      }
    },
    "RoleGroupsPatchModel": {
      "description": "Data",
      "type": "object",
      "properties": {
        "groupIdsToAdd": {
          "description": "IDs of Groups to add to Role",
          "$ref": "#/definitions/UpdateFieldValueOfInt32"
        },
        "groupIdsToRemove": {
          "description": "IDs of Groups to remove from Role",
          "$ref": "#/definitions/UpdateFieldValueOfInt32"
        }
      }
    },
    "RoleGroupsPatchResult": {
      "description": "RoleGroupsPatchResult",
      "type": "object",
      "properties": {
        "success": {
          "description": "Success",
          "type": "boolean"
        }
      }
    },
    "RoleModel": {
      "description": "Role",
      "type": "object",
      "properties": {
        "created": {
          "description": "Created",
          "type": "string",
          "format": "date-time"
        },
        "enabled": {
          "description": "Enabled",
          "type": "boolean"
        },
        "id": {
          "description": "Role Id",
          "type": "integer",
          "format": "int32"
        },
        "isSystem": {
          "description": "Is System Role",
          "type": "boolean"
        },
        "name": {
          "description": "Name",
          "type": "string"
        }
      }
    },
    "RolePatchArgs": {
      "description": "RolePatchArgs",
      "type": "object",
      "properties": {
        "data": {
          "description": "Data",
          "$ref": "#/definitions/RolePatchModel"
        }
      }
    },
    "RolePatchModel": {
      "description": "Patch Role",
      "type": "object",
      "properties": {
        "enabled": {
          "description": "Is Role Enabled",
          "$ref": "#/definitions/UpdateFieldValueOfBoolean"
        },
        "name": {
          "description": "Name of Role",
          "$ref": "#/definitions/UpdateFieldValueOfString"
        }
      }
    },
    "RolePermissionModel": {
      "description": "Role Permission",
      "type": "object",
      "properties": {
        "name": {
          "description": "Role Name",
          "type": "string"
        },
        "rolePermissionId": {
          "description": "Role Permission ID",
          "type": "integer",
          "format": "int32"
        },
        "roleType": {
          "description": "Role Type",
          "$ref": "#/definitions/RoleTypes"
        }
      }
    },
    "RolePermissionsAssignmentRequest": {
      "description": "RolePermissionsAssignmentRequest",
      "type": "object",
      "properties": {
        "rolePermissionIds": {
          "description": "This list will be the exact RolePermissions for the Role",
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        }
      }
    },
    "RolePermissionsAssignmentResponse": {
      "description": "The status of the Role Permissions change action.",
      "type": "object",
      "properties": {
        "success": {
          "description": "The success or failure of the Role Permissions action.",
          "type": "boolean"
        }
      }
    },
    "RoleSummary": {
      "description": "Role Summary",
      "type": "object",
      "properties": {
        "name": {
          "description": "Role Name",
          "type": "string"
        },
        "roleId": {
          "description": "Role ID",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "RoleTypes": {
      "description": "Role Type",
      "type": "string",
      "enum": [
        "GlobalRoleType",
        "FolderRoleType",
        "SecretRoleType",
        "SecretTemplateRoleType",
        "ReportRoleType",
        "ReportCategoryRoleType"
      ]
    },
    "SecretAccessRequired": {
      "description": "Secret Access Required",
      "type": "string",
      "enum": [
        "None",
        "RequiresApproval",
        "RequiresCheckout",
        "RequiresComment",
        "RequiresDoubleLockPassword",
        "CreateDoubleLockPassword",
        "DoubleLockNoAccess",
        "CannotView",
        "RequiresUndelete",
        "RequiresCheckoutPendingRPC",
        "RequiresCheckoutAndComment",
        "RequiresMfaChallenge"
      ]
    },
    "SecretCreateArgs": {
      "description": "Secret create options",
      "type": "object",
      "required": [
        "name",
        "secretTemplateId",
        "items"
      ],
      "properties": {
        "autoChangeEnabled": {
          "description": "Whether the secret’s password is automatically rotated on a schedule.",
          "type": "boolean"
        },
        "changePasswordNow": {
          "description": "Whether the Secret should be immediately queued for Remote Password Change upon successful import.",
          "type": "boolean"
        },
        "checkOutChangePasswordEnabled": {
          "description": "Whether the secret’s password is automatically changed when a secret is checked in. This is a security feature that prevents a use of the password retrieved from check-out after the secret is checked in.",
          "type": "boolean"
        },
        "checkOutEnabled": {
          "description": "Whether the user must check-out the secret to view it. Checking out gives the user exclusive access to the secret for a specified period or until the secret is checked in.",
          "type": "boolean"
        },
        "checkOutIntervalMinutes": {
          "description": "The number of minutes that a secret will remain checked out.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "delayIndexing": {
          "description": "Whether the search indexing should be delayed to the background process. This can speed up bulk secret creation scripts by offloading the task of indexing the new secrets to the background task at the trade-off of not having search indexes immediately available.",
          "type": "boolean",
          "x-nullable": true
        },
        "enableInheritPermissions": {
          "description": "Whether the secret inherits permissions from the containing folder.",
          "type": "boolean",
          "x-nullable": true
        },
        "enableInheritSecretPolicy": {
          "description": "Whether the secret policy is inherited from the containing folder.",
          "type": "boolean"
        },
        "folderId": {
          "description": "If the secret is contained in a folder, the id of the containing folder. Set to null or -1 for secrets that are in the root folder.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "items": {
          "description": "An array of values for the secret fields defined in the secret template.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/RestSecretItem"
          }
        },
        "launcherConnectAsSecretId": {
          "description": "When an SSH secret is proxied, you can choose to connect as another user and then do an su to the current secret’s user. This is a common practice for connecting with a lower privileged account and then switching to the root user.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "name": {
          "description": "The name to display for the secret.",
          "type": "string"
        },
        "passwordTypeWebScriptId": {
          "description": "The id of the password change script to use on applicable web password secrets.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "proxyEnabled": {
          "description": "Whether sessions launched on this secret use Secret Server’s proxying or connect directly.",
          "type": "boolean"
        },
        "requiresComment": {
          "description": "Whether the user must enter a comment to view the secret.",
          "type": "boolean"
        },
        "secretPolicyId": {
          "description": "The id of the secret policy that controls the security and other settings of the secret. Set to null to not assign a secret policy.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "secretTemplateId": {
          "description": "The id of the secret template that defines the fields and properties of the secret.",
          "type": "integer",
          "format": "int32",
          "minimum": 1
        },
        "sessionRecordingEnabled": {
          "description": "Whether session recording is enabled.",
          "type": "boolean"
        },
        "siteId": {
          "description": "The id of the distributed engine site that is used by this secret for operations such as password changing.",
          "type": "integer",
          "format": "int32",
          "minimum": 1
        },
        "sshKeyArgs": {
          "description": "SSH key options.",
          "$ref": "#/definitions/SshKeyArgs"
        },
        "webLauncherRequiresIncognitoMode": {
          "description": "Whether the web launcher will require the browser to run in incognito mode.",
          "type": "boolean"
        }
      }
    },
    "SecretDetailActionType": {
      "description": "Secret Detail Action Type",
      "type": "string",
      "enum": [
        "ChangePasswordNow",
        "ConvertTemplate",
        "Copy",
        "Delete",
        "Edit",
        "EditExpiration",
        "EditRpc",
        "EditSecurity",
        "Expire",
        "Heartbeat",
        "EditShare",
        "ShowSshProxyCredentials",
        "StopChangePasswordNow",
        "ViewAudit",
        "ViewDependencies",
        "ViewLaunchers",
        "ViewExpiration",
        "ViewHooks",
        "ViewRpc",
        "ViewSecurity",
        "ViewSettings",
        "Undelete",
        "ForceCheckin",
        "ViewShare",
        "EditHooks",
        "EditDependencies",
        "ViewGeneralDetails",
        "ViewHeartbeatStatus",
        "Checkin",
        "Checkout",
        "GenerateOneTimePassword",
        "ShowSshTerminalDetails",
        "ShowRdpProxyCredentials",
        "ViewMetadata",
        "ViewSecretExposure",
        "ViewCheckOut",
        "ViewApproval",
        "ViewListFields",
        "Erase",
        "ViewMfa"
      ]
    },
    "SecretDetailExpirationType": {
      "description": "Expiration Type",
      "type": "string",
      "enum": [
        "Template",
        "DayInterval",
        "SpecificDate",
        "Disabled"
      ]
    },
    "SecretDetailExpirationUpdateModel": {
      "description": "Data",
      "type": "object",
      "properties": {
        "expirationDate": {
          "description": "ExpirationDate",
          "$ref": "#/definitions/UpdateFieldValueOfOptionalDateTime"
        },
        "expirationDayInterval": {
          "description": "ExpirationDayInterval",
          "$ref": "#/definitions/UpdateFieldValueOfOptionalInt32"
        },
        "expirationType": {
          "description": "ExpirationType",
          "$ref": "#/definitions/UpdateFieldValueOfSecretDetailExpirationUpdateType"
        }
      }
    },
    "SecretDetailExpirationUpdateType": {
      "description": "Value",
      "type": "string",
      "enum": [
        "Template",
        "DayInterval",
        "SpecificDate"
      ]
    },
    "SecretDetailGeneralModel": {
      "description": "Secret Detail General",
      "type": "object",
      "properties": {
        "active": {
          "description": "Whether the secret is active",
          "type": "boolean"
        },
        "autoChangePassword": {
          "description": "Whether the password should automatically change upon expiration.",
          "type": "boolean"
        },
        "canGenerateSshKey": {
          "description": "Can Generate SSH Key",
          "type": "boolean"
        },
        "enableInheritSecretPolicy": {
          "description": "Whether the secret policy is inherited from the containing folder",
          "type": "boolean"
        },
        "expiration": {
          "description": "Expiration",
          "type": "string"
        },
        "fields": {
          "description": "Secret Fields",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "folder": {
          "description": "Containing folder ID",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "heartbeatEnabled": {
          "description": "Heartbeat Enabled",
          "type": "boolean"
        },
        "id": {
          "description": "Secret Detail General Id",
          "type": "integer",
          "format": "int32"
        },
        "isFavorite": {
          "description": "Is Favorite",
          "type": "boolean"
        },
        "isOutOfSync": {
          "description": "Whether the secret is out of sync",
          "type": "boolean"
        },
        "isTotpEnabled": {
          "description": "Is One Time Password Enabled",
          "type": "boolean"
        },
        "lastHeartBeatCheck": {
          "description": "Time of last heartbeat check",
          "type": "string",
          "format": "date-time",
          "x-nullable": true
        },
        "lastHeartBeatStatus": {
          "description": "Current status of heartbeat",
          "$ref": "#/definitions/SecretDetailHeartbeatStatus"
        },
        "launchers": {
          "description": "Launchers",
          "type": "array",
          "items": {
            "$ref": "#/definitions/SecretDetailLauncher"
          }
        },
        "name": {
          "description": "Secret Detail General Name",
          "type": "string"
        },
        "outOfSyncReason": {
          "description": "Reason message if the secret is out of sync",
          "type": "string"
        },
        "secretPolicy": {
          "description": "Secret Policy",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "site": {
          "description": "Site",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "slugPrivateKey": {
          "description": "Private Key Field Slug",
          "type": "string"
        },
        "slugPublicKey": {
          "description": "Public Key Field Slug",
          "type": "string"
        },
        "template": {
          "description": "Secret template",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "totpPasswordSlug": {
          "description": "One Time Password Field Slug",
          "type": "string"
        }
      }
    },
    "SecretDetailHeartbeatStatus": {
      "description": "Current status of heartbeat",
      "type": "string",
      "enum": [
        "Failed",
        "Success",
        "Pending",
        "Disabled",
        "UnableToConnect",
        "UnknownError",
        "IncompatibleHost",
        "AccountLockedOut",
        "DnsMismatch",
        "UnableToValidateServerPublicKey",
        "Processing"
      ]
    },
    "SecretDetailLauncher": {
      "description": "Launchers",
      "type": "object",
      "properties": {
        "hasProxyCredentials": {
          "description": "HasProxyCredentials",
          "type": "boolean"
        },
        "imagePath": {
          "description": "ImagePath",
          "type": "string"
        },
        "isRecorded": {
          "description": "IsRecorded",
          "type": "boolean"
        },
        "name": {
          "description": "Name",
          "type": "string"
        },
        "showLauncher": {
          "description": "ShowLauncher",
          "type": "boolean"
        },
        "typeId": {
          "description": "TypeId",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "SecretDetailSettingsModel": {
      "description": "Secret Detail Settings",
      "type": "object",
      "properties": {
        "expirationDate": {
          "description": "Expiration Date",
          "type": "string",
          "format": "date-time",
          "x-nullable": true
        },
        "expirationDayInterval": {
          "description": "Expiration Day Interval",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "expirationTemplateText": {
          "description": "Expiration Template Text",
          "type": "string"
        },
        "expirationType": {
          "description": "Expiration Type",
          "$ref": "#/definitions/SecretDetailExpirationType"
        },
        "sendEmailWhenChanged": {
          "description": "Send Email When Changed",
          "type": "boolean"
        },
        "sendEmailWhenHeartbeatFails": {
          "description": "Send Email When Heartbeat Fails",
          "type": "boolean"
        },
        "sendEmailWhenViewed": {
          "description": "Send Email When Viewed",
          "type": "boolean"
        }
      }
    },
    "SecretDetailStateActionsModel": {
      "description": "Available Secret Detail State Actions",
      "properties": {
        "extendCheckOut": {
          "description": "The user may extend the remaining check out time of the secret.",
          "type": "boolean"
        }
      }
    },
    "SecretDetailStateViewModel": {
      "description": "Secret Detail State View Model",
      "type": "object",
      "properties": {
        "actions": {
          "description": "Allowed action for current user",
          "type": "array",
          "items": {
            "$ref": "#/definitions/SecretDetailActionType"
          }
        },
        "approvalEnd": {
          "description": "Date when the current approval expires, or null if there is no open approval",
          "type": "string",
          "format": "date-time",
          "x-nullable": true
        },
        "availableActions": {
          "description": "Secret Detail State Actions",
          "$ref": "#/definitions/SecretDetailStateActionsModel"
        },
        "checkOutIntervalMinutes": {
          "description": "Number of minutes before checkout ",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "checkOutMinutesRemaining": {
          "description": "Minutes remaining in check out",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "checkedOutUserDisplayName": {
          "description": "Display Name of User that has the secret checked out",
          "type": "string"
        },
        "checkedOutUserId": {
          "description": "User Secret is checked out to",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "folderId": {
          "description": "Folder Id",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "folderName": {
          "description": "Folder Name",
          "type": "string"
        },
        "id": {
          "description": "Secret Id",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "inheritPermissions": {
          "description": "Is this secret inheriting permissions from its folder",
          "type": "boolean"
        },
        "isActive": {
          "description": "Active indicator",
          "type": "boolean",
          "x-nullable": true
        },
        "isCheckedOut": {
          "description": "Is the Secret checked out",
          "type": "boolean",
          "x-nullable": true
        },
        "isCheckedOutByCurrentUser": {
          "description": "Indicates whether the Secret is checked out by the current user",
          "type": "boolean",
          "x-nullable": true
        },
        "passwordChangeFailed": {
          "description": "The last password change failed when true",
          "type": "boolean",
          "x-nullable": true
        },
        "passwordChangePending": {
          "description": "Pending Password change on secret indicator",
          "type": "boolean",
          "x-nullable": true
        },
        "remainingTimeWarningMinuteMarker": {
          "description": "Minute mark to show check out warning",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "role": {
          "description": "Role that current user has on Secret",
          "type": "string",
          "x-nullable": true
        },
        "secretName": {
          "description": "Secret Name",
          "type": "string"
        },
        "secretState": {
          "description": "Current State of the Secret",
          "$ref": "#/definitions/SecretAccessRequired"
        },
        "warningMinutesRemaining": {
          "description": "Minutes remaining before showing check in warning",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        }
      }
    },
    "SecretDetailUpdateExpirationArgs": {
      "description": "SecretDetailUpdateExpirationArgs",
      "type": "object",
      "properties": {
        "data": {
          "description": "Data",
          "$ref": "#/definitions/SecretDetailExpirationUpdateModel"
        }
      }
    },
    "SecretFieldListType": {
      "description": "The type of list. Valid values are “None”, “Generic”, and “URL”.",
      "type": "string",
      "enum": [
        "Generic",
        "URL",
        "None"
      ]
    },
    "SecretItemUpdateArgs": {
      "description": "Secret field update options",
      "type": "object",
      "properties": {
        "comment": {
          "description": "If the secret requires a comment to view or requires approval to view, a reason for accessing the secret must be provided.",
          "type": "string"
        },
        "doubleLockPassword": {
          "description": "If the secret is DoubleLocked, this is the DoubleLock password needed to access the secret.",
          "type": "string"
        },
        "file": {
          "description": "Uploaded file (used for file attachment fields with \"Content-Type: multipart/form-data\")",
          "type": "string"
        },
        "fileAttachment": {
          "description": "Binary file data (used for file attachment fields with \"Content-Type: application/json\")",
          "type": "string",
          "format": "binary"
        },
        "fileName": {
          "description": "File name (used for file attachment fields with \"Content-Type: application/json\"))",
          "type": "string"
        },
        "forceCheckIn": {
          "description": "Force the secret to be checked in, even if checked out by someone else. The user must have the \"Force Check In\" permission.",
          "type": "boolean"
        },
        "includeInactive": {
          "description": "If the secret is deactivated, this must be set to true in order to access the secret. The user must also have the \"View Inactive Secrets\" permission.",
          "type": "boolean"
        },
        "newPassword": {
          "description": "New secret password.",
          "type": "string"
        },
        "noAutoCheckout": {
          "description": "Don't check out the secret automatically.",
          "type": "boolean"
        },
        "ticketNumber": {
          "description": "If the secret requires a comment to view or requires approval and a user must provide a help desk a ticket number, this is the ticket number to the help desk request.",
          "type": "string"
        },
        "ticketSystemId": {
          "description": "If the secret requires a comment to view or requires approval and a user must provide a help desk a ticket number, this is the id of the help desk system configured in Secret Server that should be used to validate the ticket number.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "value": {
          "description": "New value to assign to the secret field.",
          "type": "string"
        }
      }
    },
    "SecretListFieldListArgs": {
      "description": "Secret List Field List Args",
      "type": "object",
      "properties": {
        "listGuids": {
          "description": "Array of List GUIDs",
          "type": "array",
          "items": {
            "type": "string",
            "format": "uuid"
          }
        }
      }
    },
    "SecretLookup": {
      "description": "Simple secret representation",
      "type": "object",
      "properties": {
        "id": {
          "description": "Secret ID",
          "type": "integer",
          "format": "int32"
        },
        "value": {
          "description": "Secret name",
          "type": "string"
        }
      }
    },
    "SecretModel": {
      "description": "Secret",
      "type": "object",
      "properties": {
        "accessRequestWorkflowMapId": {
          "description": "AccessRequestWorkflowMapId",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "active": {
          "description": "Whether the secret is active",
          "type": "boolean"
        },
        "allowOwnersUnrestrictedSshCommands": {
          "description": "AllowOwnersUnrestrictedSshCommands",
          "type": "boolean"
        },
        "autoChangeEnabled": {
          "description": "AutoChangeEnabled",
          "type": "boolean"
        },
        "autoChangeNextPassword": {
          "description": "AutoChangeNextPassword",
          "type": "string"
        },
        "checkOutChangePasswordEnabled": {
          "description": "CheckOutChangePasswordEnabled",
          "type": "boolean"
        },
        "checkOutEnabled": {
          "description": "Whether secret checkout is enabled",
          "type": "boolean"
        },
        "checkOutIntervalMinutes": {
          "description": "Checkout interval, in minutes",
          "type": "integer",
          "format": "int32"
        },
        "checkOutMinutesRemaining": {
          "description": "Minutes remaining in current checkout interval",
          "type": "integer",
          "format": "int32"
        },
        "checkOutUserDisplayName": {
          "description": "Name of user who has checked out the secret",
          "type": "string"
        },
        "checkOutUserId": {
          "description": "ID of user who has checked out the secret",
          "type": "integer",
          "format": "int32"
        },
        "checkedOut": {
          "description": "Whether the secret is currently checked out",
          "type": "boolean"
        },
        "doubleLockId": {
          "description": "DoubleLockId",
          "type": "integer",
          "format": "int32"
        },
        "enableInheritPermissions": {
          "description": "EnableInheritPermissions",
          "type": "boolean"
        },
        "enableInheritSecretPolicy": {
          "description": "Whether the secret policy is inherited from the containing folder",
          "type": "boolean"
        },
        "failedPasswordChangeAttempts": {
          "description": "Number of failed password change attempts",
          "type": "integer",
          "format": "int32"
        },
        "folderId": {
          "description": "Containing folder ID",
          "type": "integer",
          "format": "int32"
        },
        "id": {
          "description": "Secret ID",
          "type": "integer",
          "format": "int32"
        },
        "isDoubleLock": {
          "description": "Whether double lock is enabled",
          "type": "boolean"
        },
        "isOutOfSync": {
          "description": "Out of sync indicates that a Password is setup for autochange and has failed its last password change attempt or has exceeded the maximum RPC attempts",
          "type": "boolean"
        },
        "isRestricted": {
          "description": "Whether the secret is restricted",
          "type": "boolean"
        },
        "items": {
          "description": "Secret data fields",
          "type": "array",
          "items": {
            "$ref": "#/definitions/RestSecretItem"
          }
        },
        "jumpboxRouteId": {
          "description": "JumpboxRouteId",
          "type": "string",
          "format": "uuid",
          "x-nullable": true
        },
        "lastHeartBeatCheck": {
          "description": "Time of last heartbeat check",
          "type": "string",
          "format": "date-time"
        },
        "lastHeartBeatStatus": {
          "description": "Current status of heartbeat",
          "$ref": "#/definitions/HeartbeatStatus"
        },
        "lastPasswordChangeAttempt": {
          "description": "Time of most recent password change attempt",
          "type": "string",
          "format": "date-time"
        },
        "launcherConnectAsSecretId": {
          "description": "LauncherConnectAsSecretId",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "name": {
          "description": "Secret name",
          "type": "string"
        },
        "outOfSyncReason": {
          "description": "Reason message if the secret is out of sync",
          "type": "string"
        },
        "passwordTypeWebScriptId": {
          "description": "PasswordTypeWebScriptId",
          "type": "integer",
          "format": "int32"
        },
        "proxyEnabled": {
          "description": "ProxyEnabled",
          "type": "boolean"
        },
        "requiresApprovalForAccess": {
          "description": "RequiresApprovalForAccess",
          "type": "boolean"
        },
        "requiresComment": {
          "description": "RequiresComment",
          "type": "boolean"
        },
        "responseCodes": {
          "description": "ResponseCodes",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "restrictSshCommands": {
          "description": "RestrictSshCommands",
          "type": "boolean"
        },
        "secretPolicyId": {
          "description": "SecretPolicyId",
          "type": "integer",
          "format": "int32"
        },
        "secretTemplateId": {
          "description": "Secret template ID",
          "type": "integer",
          "format": "int32"
        },
        "secretTemplateName": {
          "description": "Name of secret template",
          "type": "string"
        },
        "sessionRecordingEnabled": {
          "description": "Whether session recording is enabled",
          "type": "boolean"
        },
        "siteId": {
          "description": "SiteId",
          "type": "integer",
          "format": "int32"
        },
        "webLauncherRequiresIncognitoMode": {
          "description": "WebLauncherRequiresIncognitoMode",
          "type": "boolean"
        }
      }
    },
    "SecretModelV2": {
      "description": "Secret V2",
      "type": "object",
      "properties": {
        "accessRequestWorkflowMapId": {
          "description": "Access Request Workflow Map Id",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "active": {
          "description": "Whether the secret is active",
          "type": "boolean"
        },
        "allowOwnersUnrestrictedSshCommands": {
          "description": "Allow Owners Unrestricted SSH Commands",
          "type": "boolean"
        },
        "autoChangeEnabled": {
          "description": "Auto Change Enabled",
          "type": "boolean"
        },
        "autoChangeNextPassword": {
          "description": "Auto Change Next Password",
          "type": "string"
        },
        "checkOutChangePasswordEnabled": {
          "description": "Check Out Change Password Enabled",
          "type": "boolean"
        },
        "checkOutEnabled": {
          "description": "Whether secret checkout is enabled",
          "type": "boolean"
        },
        "checkOutIntervalMinutes": {
          "description": "Checkout interval, in minutes",
          "type": "integer",
          "format": "int32"
        },
        "checkOutMinutesRemaining": {
          "description": "Minutes remaining in current checkout interval",
          "type": "integer",
          "format": "int32"
        },
        "checkOutUserDisplayName": {
          "description": "Name of user who has checked out the secret",
          "type": "string"
        },
        "checkOutUserId": {
          "description": "ID of user who has checked out the secret",
          "type": "integer",
          "format": "int32"
        },
        "checkedOut": {
          "description": "Whether the secret is currently checked out",
          "type": "boolean"
        },
        "doubleLockId": {
          "description": "DoubleLock Id",
          "type": "integer",
          "format": "int32"
        },
        "enableInheritPermissions": {
          "description": "Enable Inherit Permissions",
          "type": "boolean"
        },
        "enableInheritSecretPolicy": {
          "description": "Whether the secret policy is inherited from the containing folder",
          "type": "boolean"
        },
        "failedPasswordChangeAttempts": {
          "description": "Number of failed password change attempts",
          "type": "integer",
          "format": "int32"
        },
        "folderId": {
          "description": "Containing folder ID",
          "type": "integer",
          "format": "int32"
        },
        "id": {
          "description": "Secret ID",
          "type": "integer",
          "format": "int32"
        },
        "isDoubleLock": {
          "description": "Whether double lock is enabled",
          "type": "boolean"
        },
        "isOutOfSync": {
          "description": "Out of sync indicates that a Password is setup for autochange and has failed its last password change attempt or has exceeded the maximum RPC attempts",
          "type": "boolean"
        },
        "isRestricted": {
          "description": "Whether the secret is restricted",
          "type": "boolean"
        },
        "items": {
          "description": "Secret data fields",
          "type": "array",
          "items": {
            "$ref": "#/definitions/RestSecretItem"
          }
        },
        "jumpboxRouteId": {
          "description": "Jumpbox Route Id",
          "type": "string",
          "format": "uuid",
          "x-nullable": true
        },
        "lastHeartBeatCheck": {
          "description": "Time of last heartbeat check",
          "type": "string",
          "format": "date-time",
          "x-nullable": true
        },
        "lastHeartBeatStatus": {
          "description": "Current status of heartbeat",
          "$ref": "#/definitions/HeartbeatStatus"
        },
        "lastPasswordChangeAttempt": {
          "description": "Time of most recent password change attempt",
          "type": "string",
          "format": "date-time",
          "x-nullable": true
        },
        "launcherConnectAsSecretId": {
          "description": "LauncherConnectAsSecretId",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "name": {
          "description": "Secret name",
          "type": "string"
        },
        "outOfSyncReason": {
          "description": "Reason message if the secret is out of sync",
          "type": "string"
        },
        "passwordTypeWebScriptId": {
          "description": "Password Type Web Script Id",
          "type": "integer",
          "format": "int32"
        },
        "proxyEnabled": {
          "description": "Proxy Enabled",
          "type": "boolean"
        },
        "requiresApprovalForAccess": {
          "description": "Requires Approval For Access",
          "type": "boolean"
        },
        "requiresComment": {
          "description": "Requires Comment",
          "type": "boolean"
        },
        "responseCodes": {
          "description": "Response Codes",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "restrictSshCommands": {
          "description": "Restrict SSH Commands",
          "type": "boolean"
        },
        "secretPolicyId": {
          "description": "Secret Policy Id",
          "type": "integer",
          "format": "int32"
        },
        "secretTemplateId": {
          "description": "Secret template ID",
          "type": "integer",
          "format": "int32"
        },
        "secretTemplateName": {
          "description": "Name of secret template",
          "type": "string"
        },
        "sessionRecordingEnabled": {
          "description": "Whether session recording is enabled",
          "type": "boolean"
        },
        "siteId": {
          "description": "Site Id",
          "type": "integer",
          "format": "int32"
        },
        "webLauncherRequiresIncognitoMode": {
          "description": "Web Launcher Requires Incognito Mode",
          "type": "boolean"
        }
      }
    },
    "SecretRestrictedArgs": {
      "description": "Restricted secret update options",
      "type": "object",
      "properties": {
        "comment": {
          "description": "If the secret requires a comment to view or requires approval to view, a reason for accessing the secret must be provided.",
          "type": "string"
        },
        "doubleLockPassword": {
          "description": "If the secret is DoubleLocked, this is the DoubleLock password needed to access the secret.",
          "type": "string"
        },
        "forceCheckIn": {
          "description": "Force the secret to be checked in, even if checked out by someone else. The user must have the \"Force Check In\" permission.",
          "type": "boolean"
        },
        "includeInactive": {
          "description": "If the secret is deactivated, this must be set to true in order to access the secret. The user must also have the \"View Inactive Secrets\" permission.",
          "type": "boolean"
        },
        "newPassword": {
          "description": "New secret password.",
          "type": "string"
        },
        "noAutoCheckout": {
          "description": "Don't check out the secret automatically.",
          "type": "boolean"
        },
        "ticketNumber": {
          "description": "If the secret requires a comment to view or requires approval and a user must provide a help desk a ticket number, this is the ticket number to the help desk request.",
          "type": "string"
        },
        "ticketSystemId": {
          "description": "If the secret requires a comment to view or requires approval and a user must provide a help desk a ticket number, this is the id of the help desk system configured in Secret Server that should be used to validate the ticket number.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        }
      }
    },
    "SecretSearchExtendedArgs": {
      "description": "SecretSearchExtendedArgs",
      "type": "object",
      "properties": {
        "data": {
          "description": "Data",
          "$ref": "#/definitions/SecretSearchExtendedData"
        }
      }
    },
    "SecretSearchExtendedData": {
      "description": "Data",
      "type": "object",
      "properties": {
        "secretIds": {
          "description": "Pass an array of secret IDs to get back settings on these secrets for the current user",
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        }
      }
    },
    "SecretSearchExtendedSummary": {
      "description": "SecretSearchExtendedSummary[]",
      "type": "object",
      "properties": {
        "hasLaunchers": {
          "description": "Does this Secret have launchers the current user can use",
          "type": "boolean"
        },
        "isFavorite": {
          "description": "Is this a favorite secret for the current user",
          "type": "boolean"
        },
        "lastAccessed": {
          "description": "Does this Secret have launchers the current user can use",
          "type": "string",
          "format": "date-time",
          "x-nullable": true
        },
        "secretId": {
          "description": "Secret ID",
          "type": "integer",
          "format": "int32"
        },
        "secretName": {
          "description": "Secret Name",
          "type": "string"
        },
        "totalSecretViews": {
          "description": "Does this Secret have launchers the current user can use",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "SecretSummary": {
      "description": "Secret summary",
      "type": "object",
      "properties": {
        "active": {
          "description": "Whether the secret is active",
          "type": "boolean"
        },
        "autoChangeEnabled": {
          "description": "Indicates whether or not this Secret an auto changing password",
          "type": "boolean",
          "x-nullable": true
        },
        "checkOutEnabled": {
          "description": "Indicates whether or not checkout is enabled for the Secret",
          "type": "boolean",
          "x-nullable": true
        },
        "checkOutUserId": {
          "description": "Id of the User that has the secret checked out if it is checked out",
          "type": "integer",
          "format": "int32"
        },
        "checkOutUserName": {
          "description": "The name of the User that has the secret checked out if it is checked out",
          "type": "string"
        },
        "checkedOut": {
          "description": "Whether the secret is currently checked out",
          "type": "boolean"
        },
        "createDate": {
          "description": "When the Secret was created",
          "type": "string",
          "format": "date-time",
          "x-nullable": true
        },
        "daysUntilExpiration": {
          "description": "How many days until this Secret expires",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "doubleLockEnabled": {
          "description": "Indicates whether or not DoubleLock is enabled for this password",
          "type": "boolean",
          "x-nullable": true
        },
        "extendedFields": {
          "description": "Any requested extended fields from a lookup request",
          "type": "array",
          "items": {
            "$ref": "#/definitions/ISecretSummaryExtendedField"
          }
        },
        "folderId": {
          "description": "Containing folder ID",
          "type": "integer",
          "format": "int32"
        },
        "folderPath": {
          "description": "Containing folder path",
          "type": "string"
        },
        "hasLauncher": {
          "description": "Indicates if this Secret has any launchers",
          "type": "boolean"
        },
        "hidePassword": {
          "description": "Indicates if the launcher password is set to be hidden",
          "type": "boolean",
          "x-nullable": true
        },
        "id": {
          "description": "Secret ID",
          "type": "integer",
          "format": "int32"
        },
        "inheritsPermissions": {
          "description": "Indicates if this Secret inherits permissions from its folder",
          "type": "boolean",
          "x-nullable": true
        },
        "isOutOfSync": {
          "description": "Indicates that Heartbeat has failed or a Password is set up for autochange and has failed its last password change attempt or has exceeded the maximum RPC attempts",
          "type": "boolean"
        },
        "isRestricted": {
          "description": "Whether the secret is restricted",
          "type": "boolean"
        },
        "lastAccessed": {
          "description": "When the Secret was last viewed by the current User",
          "type": "string",
          "format": "date-time",
          "x-nullable": true
        },
        "lastHeartBeatStatus": {
          "description": "Current status of heartbeat",
          "$ref": "#/definitions/HeartbeatStatus"
        },
        "lastPasswordChangeAttempt": {
          "description": "Time of most recent password change attempt",
          "type": "string",
          "format": "date-time",
          "x-nullable": true
        },
        "name": {
          "description": "Secret name",
          "type": "string"
        },
        "outOfSyncReason": {
          "description": "Reason message if the secret is out of sync",
          "type": "string"
        },
        "requiresApproval": {
          "description": "Indicates if this Secret requires approval",
          "type": "boolean",
          "x-nullable": true
        },
        "requiresComment": {
          "description": "Indicates if this Secret requires comment",
          "type": "boolean",
          "x-nullable": true
        },
        "responseCodes": {
          "description": "ResponseCodes",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "secretTemplateId": {
          "description": "Secret template ID",
          "type": "integer",
          "format": "int32"
        },
        "secretTemplateName": {
          "description": "Name of secret template",
          "type": "string"
        },
        "siteId": {
          "description": "SiteId",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "SecretUpdateArgs": {
      "description": "Secret update options",
      "type": "object",
      "required": [
        "id",
        "name",
        "items"
      ],
      "properties": {
        "accessRequestWorkflowMapId": {
          "description": "The id of the mapping entity that associates this secret to a specific access request workflow.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "active": {
          "description": "Whether the secret is in an active or deleted state.",
          "type": "boolean"
        },
        "autoChangeEnabled": {
          "description": "Whether the secret’s password is automatically rotated on a schedule.",
          "type": "boolean"
        },
        "autoChangeNextPassword": {
          "description": "Whether the secret should be flagged for immediate password change.",
          "type": "string"
        },
        "checkOutChangePasswordEnabled": {
          "description": "Whether the secret’s password is automatically changed when a secret is checked in. This is a security feature that prevents a use of the password retrieved from check-out after the secret is checked in.",
          "type": "boolean"
        },
        "checkOutEnabled": {
          "description": "Whether the user must check-out the secret to view it. Checking out gives the user exclusive access to the secret for a specified period or until the secret is checked in.",
          "type": "boolean"
        },
        "checkOutIntervalMinutes": {
          "description": "The number of minutes that a secret will remain checked out.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "comment": {
          "description": "If the secret requires a comment to view or requires approval to view, a reason for accessing the secret must be provided.",
          "type": "string"
        },
        "doubleLockPassword": {
          "description": "If the secret is DoubleLocked, this is the DoubleLock password needed to access the secret.",
          "type": "string"
        },
        "enableInheritPermissions": {
          "description": "Whether the secret inherits permissions from the containing folder.",
          "type": "boolean",
          "x-nullable": true
        },
        "enableInheritSecretPolicy": {
          "description": "Whether the secret policy is inherited from the containing folder.",
          "type": "boolean"
        },
        "folderId": {
          "description": "If the secret is contained in a folder, the id of the containing folder. Set to null or -1 for secrets that are in the root folder.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "forceCheckIn": {
          "description": "Force the secret to be checked in, even if checked out by someone else. The user must have the \"Force Check In\" permission.",
          "type": "boolean"
        },
        "id": {
          "description": "The id of the Secret to update. Must match the {id} in the path.",
          "type": "integer",
          "format": "int32",
          "minimum": 1
        },
        "includeInactive": {
          "description": "If the secret is deactivated, this must be set to true in order to access the secret. The user must also have the \"View Inactive Secrets\" permission.",
          "type": "boolean"
        },
        "items": {
          "description": "A list of secret item field values.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/RestSecretItem"
          }
        },
        "launcherConnectAsSecretId": {
          "description": "When an SSH secret is proxied, you can choose to connect as another user and then do an su to the current secret’s user. This is a common practice for connecting with a lower privileged account and then switching to the root user.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "name": {
          "description": "The name to display for the secret.",
          "type": "string"
        },
        "newPassword": {
          "description": "New secret password.",
          "type": "string"
        },
        "noAutoCheckout": {
          "description": "Don't check out the secret automatically.",
          "type": "boolean"
        },
        "passwordTypeWebScriptId": {
          "description": "The id of the password change script to use on applicable web password secrets.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "proxyEnabled": {
          "description": "Whether sessions launched on this secret use Secret Server’s proxying or connect directly.",
          "type": "boolean"
        },
        "requiresComment": {
          "description": "Whether the user must enter a comment to view the secret.",
          "type": "boolean"
        },
        "secretPolicyId": {
          "description": "The id of the secret policy that controls the security and other settings of the secret. Set to null to not assign a secret policy.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "sessionRecordingEnabled": {
          "description": "Whether session recording is enabled.",
          "type": "boolean"
        },
        "siteId": {
          "description": "The id of the distributed engine site that is used by this secret for operations such as password changing.",
          "type": "integer",
          "format": "int32",
          "minimum": 1
        },
        "sshKeyArgs": {
          "description": "SSH key options",
          "$ref": "#/definitions/SshKeyArgs"
        },
        "ticketNumber": {
          "description": "If the secret requires a comment to view or requires approval and a user must provide a help desk a ticket number, this is the ticket number to the help desk request.",
          "type": "string"
        },
        "ticketSystemId": {
          "description": "If the secret requires a comment to view or requires approval and a user must provide a help desk a ticket number, this is the id of the help desk system configured in Secret Server that should be used to validate the ticket number.",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        },
        "webLauncherRequiresIncognitoMode": {
          "description": "Whether the web launcher will require the browser to run in incognito mode.",
          "type": "boolean",
          "x-nullable": true
        }
      }
    },
    "Severity": {
      "description": "Error severity level",
      "type": "string",
      "enum": [
        "None",
        "Retry",
        "Warn",
        "Critical",
        "Fatal"
      ]
    },
    "Sort": {
      "description": "Sort options. Multiple sort options can be provided in the query string.",
      "type": "object",
      "required": [
        "name",
        "direction"
      ],
      "properties": {
        "direction": {
          "description": "Sort direction",
          "$ref": "#/definitions/SortDirection"
        },
        "name": {
          "description": "Sort field name",
          "type": "string"
        },
        "priority": {
          "description": "Priority index. Sorts with lower values are executed earlier",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "SortDirection": {
      "description": "Sort direction",
      "type": "string",
      "enum": [
        "None",
        "Asc",
        "Desc"
      ]
    },
    "SshKeyArgs": {
      "description": "SSH key options",
      "type": "object",
      "properties": {
        "generatePassphrase": {
          "description": "Whether to generate an SSH private key passphrase.  Only applicable when the Secret template has a password changer with the Private Key Passphrase field mapped.  If it is not mapped, this setting is ignored.",
          "type": "boolean"
        },
        "generateSshKeys": {
          "description": "Whether to generate an SSH private key",
          "type": "boolean"
        }
      }
    },
    "TokenErrorResponse": {
      "description": "API access token error response",
      "type": "object",
      "required": [
        "message"
      ],
      "properties": {
        "message": {
          "description": "Authentication token",
          "type": "string"
        }
      }
    },
    "TokenResponse": {
      "description": "API access token response",
      "type": "object",
      "required": [
        "access_token",
        "token_type",
        "expires_in"
      ],
      "properties": {
        "access_token": {
          "description": "Authentication token",
          "type": "string"
        },
        "expires_in": {
          "description": "Authentication token expiration time, in seconds",
          "type": "string"
        },
        "refresh_token": {
          "description": "Refresh token.  This is only provided when the server is set to allow refresh tokens for web services and when the session timeout duration is not set to Unlimited.",
          "type": "string"
        },
        "token_type": {
          "description": "Authentication token type",
          "type": "string",
          "enum": [
            "bearer"
          ]
        }
      }
    },
    "UpdateFieldValueOfBoolean": {
      "description": "Active",
      "type": "object",
      "properties": {
        "dirty": {
          "description": "Dirty",
          "type": "boolean"
        },
        "value": {
          "description": "Value",
          "type": "boolean"
        }
      }
    },
    "UpdateFieldValueOfInt32": {
      "description": "FolderIds",
      "type": "object",
      "properties": {
        "dirty": {
          "description": "Dirty",
          "type": "boolean"
        },
        "value": {
          "description": "Value",
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        }
      }
    },
    "UpdateFieldValueOfOptionalDateTime": {
      "description": "Update when the pinned folder was last viewed",
      "type": "object",
      "properties": {
        "dirty": {
          "description": "Dirty",
          "type": "boolean"
        },
        "value": {
          "description": "Value",
          "type": "string",
          "format": "date-time",
          "x-nullable": true
        }
      }
    },
    "UpdateFieldValueOfOptionalInt32": {
      "description": "The minimum length required for local user passwords",
      "type": "object",
      "properties": {
        "dirty": {
          "description": "Dirty",
          "type": "boolean"
        },
        "value": {
          "description": "Value",
          "type": "integer",
          "format": "int32",
          "x-nullable": true
        }
      }
    },
    "UpdateFieldValueOfSecretDetailExpirationUpdateType": {
      "description": "ExpirationType",
      "type": "object",
      "properties": {
        "dirty": {
          "description": "Dirty",
          "type": "boolean"
        },
        "value": {
          "description": "Value",
          "$ref": "#/definitions/SecretDetailExpirationUpdateType"
        }
      }
    },
    "UpdateFieldValueOfString": {
      "description": "Description",
      "type": "object",
      "properties": {
        "dirty": {
          "description": "Dirty",
          "type": "boolean"
        },
        "value": {
          "description": "Value",
          "type": "string"
        }
      }
    },
    "UserIpAddressRestrictionModel": {
      "description": "UserIpAddressRestrictionModel",
      "type": "object",
      "properties": {
        "id": {
          "description": "Id",
          "type": "integer",
          "format": "int32"
        },
        "ipAddressRestrictionId": {
          "description": "IpAddressRestrictionId",
          "type": "integer",
          "format": "int32"
        },
        "ipAddressRestrictionName": {
          "description": "IpAddressRestrictionName",
          "type": "string"
        },
        "userDisplayName": {
          "description": "UserDisplayName",
          "type": "string"
        },
        "userId": {
          "description": "UserId",
          "type": "integer",
          "format": "int32"
        },
        "userName": {
          "description": "UserName",
          "type": "string"
        }
      }
    },
    "UserLookup": {
      "description": "Simple user representation",
      "type": "object",
      "properties": {
        "id": {
          "description": "User ID",
          "type": "integer",
          "format": "int32"
        },
        "value": {
          "description": "User name",
          "type": "string"
        }
      }
    },
    "UserModel": {
      "description": "User",
      "type": "object",
      "properties": {
        "adAccountExpires": {
          "description": "Active Directory account expiration time",
          "type": "string",
          "format": "date-time"
        },
        "adGuid": {
          "description": "Active Directory unique identifier",
          "type": "string"
        },
        "created": {
          "description": "User creation time",
          "type": "string",
          "format": "date-time"
        },
        "dateOptionId": {
          "description": "DateOptionId",
          "type": "integer",
          "format": "int32"
        },
        "displayName": {
          "description": "Display name",
          "type": "string"
        },
        "domainId": {
          "description": "Active Directory domain ID",
          "type": "integer",
          "format": "int32"
        },
        "duoTwoFactor": {
          "description": "Whether Duo two-factor authentication is enabled",
          "type": "boolean"
        },
        "emailAddress": {
          "description": "Email address",
          "type": "string"
        },
        "enabled": {
          "description": "Whether the user account is enabled",
          "type": "boolean"
        },
        "fido2TwoFactor": {
          "description": "Whether FIDO2 two-factor authentication is enabled",
          "type": "boolean"
        },
        "id": {
          "description": "User ID",
          "type": "integer",
          "format": "int32"
        },
        "ipAddressRestrictions": {
          "description": "Array of IP Address Restrictions for the user.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UserIpAddressRestrictionModel"
          }
        },
        "isApplicationAccount": {
          "description": "IsApplicationAccount",
          "type": "boolean"
        },
        "isEmailCopiedFromAD": {
          "description": "Whether the email address is derived from the Active Directory account",
          "type": "boolean"
        },
        "isEmailVerified": {
          "description": "Whether the email address has been verified",
          "type": "boolean"
        },
        "isLockedOut": {
          "description": "Whether the user is locked out",
          "type": "boolean"
        },
        "lastLogin": {
          "description": "Time of last login",
          "type": "string",
          "format": "date-time"
        },
        "lastSessionActivity": {
          "description": "Time of last session activity",
          "type": "string",
          "format": "date-time",
          "x-nullable": true
        },
        "lockOutReason": {
          "description": "The reason for the lock out",
          "type": "string",
          "x-nullable": true
        },
        "lockOutReasonDescription": {
          "description": "An optional description of the reason for the lock out",
          "type": "string"
        },
        "loginFailures": {
          "description": "Number of login failures",
          "type": "integer",
          "format": "int32"
        },
        "mustVerifyEmail": {
          "description": "Whether the user must verify their email address",
          "type": "boolean"
        },
        "oathTwoFactor": {
          "description": "Whether OATH two-factor authentication is enabled",
          "type": "boolean"
        },
        "oathVerified": {
          "description": "Whether OATH has been verified",
          "type": "boolean"
        },
        "passwordLastChanged": {
          "description": "Time when the password was last changed",
          "type": "string",
          "format": "date-time"
        },
        "personalGroupId": {
          "description": "The personal group ID for this user.  Each user has a personal group that is a group that only contains that user.",
          "type": "integer",
          "format": "int32"
        },
        "radiusTwoFactor": {
          "description": "Whether RADIUS two-factor authentication is enabled",
          "type": "boolean"
        },
        "radiusUserName": {
          "description": "RADIUS username",
          "type": "string"
        },
        "resetSessionStarted": {
          "description": "ResetSessionStarted",
          "type": "string",
          "format": "date-time"
        },
        "slackId": {
          "description": "Slack ID of the user",
          "type": "string"
        },
        "timeOptionId": {
          "description": "TimeOptionId",
          "type": "integer",
          "format": "int32"
        },
        "twoFactor": {
          "description": "Whether two-factor authentication is enabled",
          "type": "boolean"
        },
        "userLcid": {
          "description": "UserLcid",
          "type": "integer",
          "format": "int32"
        },
        "userName": {
          "description": "User name",
          "type": "string"
        },
        "verifyEmailSentDate": {
          "description": "Time when the verification email was sent",
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "UserRoleSummary": {
      "description": "All of the roles a user has",
      "type": "object",
      "properties": {
        "groups": {
          "description": "All of the groups to which the user belongs that have this role",
          "type": "array",
          "items": {
            "$ref": "#/definitions/GroupAssignedRoleModel"
          }
        },
        "isDirectAssignment": {
          "description": "Is the role directly assigned to the user",
          "type": "boolean"
        },
        "roleId": {
          "description": "Role ID",
          "type": "integer",
          "format": "int32"
        },
        "roleName": {
          "description": "Role Name",
          "type": "string"
        }
      }
    },
    "UserUpdateArgs": {
      "description": "User update options",
      "type": "object",
      "properties": {
        "dateOptionId": {
          "description": "The id of the date format to use when displaying dates to this user. These options are defined in Admin \u003e Configuration.",
          "type": "integer",
          "format": "int32"
        },
        "displayName": {
          "description": "The user’s name as displayed in the user interface.",
          "type": "string"
        },
        "duoTwoFactor": {
          "description": "Whether Duo two-factor authentication is enabled.",
          "type": "boolean"
        },
        "emailAddress": {
          "description": "The user's email address. Used by the system to send reports, access requests, and other notifications.",
          "type": "string"
        },
        "enabled": {
          "description": "Whether the user account is enabled. Disabled users are unable to log in and do not consume a user license.",
          "type": "boolean"
        },
        "fido2TwoFactor": {
          "description": "Whether FIDO2 two-factor authentication is enabled.",
          "type": "boolean"
        },
        "groupOwners": {
          "description": "A list of group ids for the groups that can manage this user. If not set, the user is managed by all users with the ‘Administer Users’ role permission.",
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        },
        "id": {
          "description": "User ID. Must match ID in path.",
          "type": "integer",
          "format": "int32",
          "minimum": 1
        },
        "isApplicationAccount": {
          "description": "Whether this is an application account. Application accounts are used for automation, cannot log in using the UI, and do not consume a user license.",
          "type": "boolean"
        },
        "isGroupOwnerUpdate": {
          "description": "Whether the user is managed by the groups specified in GroupOwners or is managed by all users with the ‘Administer Users’ role permission.",
          "type": "boolean"
        },
        "isLockedOut": {
          "description": "Whether the user is locked out. A locked out user cannot log in.",
          "type": "boolean"
        },
        "loginFailures": {
          "description": "Number of login failures to allow before the account is locked out. Set to 0 for unlimited login attempts.",
          "type": "integer",
          "format": "int32",
          "minimum": 0
        },
        "oathTwoFactor": {
          "description": "Whether OATH two-factor authentication is enabled.",
          "type": "boolean"
        },
        "password": {
          "description": "The password used by local accounts to log in.",
          "type": "string"
        },
        "radiusTwoFactor": {
          "description": "Whether RADIUS two-factor authentication is enabled.",
          "type": "boolean"
        },
        "radiusUserName": {
          "description": "When a user account uses RADIUS two-factor authentication, this property is the user name of the RADIUS account used to authenticate this user.",
          "type": "string"
        },
        "timeOptionId": {
          "description": "The id of the time format to use when displaying times to this user. These options are defined in Admin \u003e Configuration.",
          "type": "integer",
          "format": "int32"
        },
        "twoFactor": {
          "description": "Whether two-factor authentication is enabled.",
          "type": "boolean"
        }
      }
    }
  },
  "securityDefinitions": {
    "Bearer": {
      "type": "apiKey",
      "name": "Authorization",
      "in": "header"
    }
  },
  "tags": [
    {
      "description": "Authenticate against Secret Server and acquire a token for other API requests",
      "name": "Authentication"
    },
    {
      "description": "View and maintain Secrets",
      "name": "Secrets"
    }
  ]
}`))
}
